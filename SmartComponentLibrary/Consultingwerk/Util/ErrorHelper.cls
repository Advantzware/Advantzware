/**********************************************************************
 * Copyright (C) 2006-2016 by Consultingwerk Ltd. ("CW") -            *
 * www.consultingwerk.de and other contributors as listed             *
 * below.  All Rights Reserved.                                       *
 *                                                                    *
 *  Software is distributed on an "AS IS", WITHOUT WARRANTY OF ANY    *
 *   KIND, either express or implied.                                 *
 *                                                                    *
 *  Contributors:                                                     *
 *                                                                    *
 **********************************************************************/
/*------------------------------------------------------------------------
    File        : ErrorHelper
    Purpose     : Various support routines for structured error handling
    Syntax      : Static methods only, Protected constructor to disallow
                  instance creation
    Description :
    Author(s)   : Mike Fechner / Consultingwerk Ltd.
    Created     : Sat Jul 04 13:29:48 CEST 2009
    Notes       :
  ----------------------------------------------------------------------*/

ROUTINE-LEVEL ON ERROR UNDO, THROW.

{ Consultingwerk/products.i }

USING Consultingwerk.Assertion.*             FROM PROPATH .
USING Consultingwerk.Exceptions.*            FROM PROPATH .
USING Consultingwerk.Framework.*             FROM PROPATH .
USING Consultingwerk.Framework.Collections.* FROM PROPATH .
USING Consultingwerk.Util.*                  FROM PROPATH .
USING Consultingwerk.Util.Forms.*            FROM PROPATH .
&IF NOT PROVERSION BEGINS "10.2" &THEN
USING Progress.Json.ObjectModel.*            FROM PROPATH .
&ENDIF
USING Progress.Lang.*                        FROM PROPATH .

CLASS Consultingwerk.Util.ErrorHelper:

    DEFINE PROTECTED STATIC VARIABLE oListIErrorHandler AS ListIErrorHandler NO-UNDO .

    /* The stack trace of who called the ErrorHelper:ShowErrorMessage or ShowErrorMessageBox
       method */
    DEFINE PRIVATE STATIC VARIABLE cStackTrace AS CHARACTER INITIAL "":U NO-UNDO .

    /**
     * Purpose: Protected default constructor.
     * Notes:   There's no need to create instances of the helper classes
     */
    CONSTRUCTOR PROTECTED ErrorHelper ():
        SUPER ().

    END CONSTRUCTOR.

    /**
     * Purpose: Returns the current ABL stack trace
     * Notes:   Throws an AppError to receive the stack trace, works also when
     *          SESSION:ERROR-STATUS-TRACE is generally set to FALSE
     * @return The current ABL Stacktrace
     */
    DEFINE PUBLIC STATIC PROPERTY CurrentStacktrace AS CHARACTER NO-UNDO
    GET():

        DEFINE VARIABLE cStacktrace        AS CHARACTER NO-UNDO .
        DEFINE VARIABLE lCurrentErrorStack AS LOGICAL   NO-UNDO .
        DEFINE VARIABLE iIndex             AS INTEGER   NO-UNDO .

        ASSIGN lCurrentErrorStack         = SESSION:ERROR-STACK-TRACE
               SESSION:ERROR-STACK-TRACE  = TRUE .

        DO ON ERROR UNDO, THROW:
            UNDO, THROW NEW AppError () .

            CATCH err AS Progress.Lang.Error:
                ASSIGN cStacktrace = err:CallStack .
            END CATCH.
        END.

        ASSIGN iIndex = INDEX (cStacktrace, CHR (10)) .

        IF iIndex > 1 THEN
            ASSIGN cStacktrace = SUBSTRING (cStacktrace, iIndex + 1, -1, "CHARACTER":U) .

        RETURN cStacktrace .

        FINALLY:
            ASSIGN SESSION:ERROR-STACK-TRACE = lCurrentErrorStack .
        END FINALLY.

    END GET.

    /**
     * Purpose: Allows to control if the ShowErrorMessage methods are allowed
     *          to show an error message using a GUI for .NET Form
     * Notes:   When set to FALSE the message is delegated to the ShowErrorMessageBox
     *          methods
     */
    DEFINE PUBLIC STATIC PROPERTY ErrorMessageDialogAllowed AS LOGICAL INITIAL TRUE NO-UNDO
    GET.
    SET.

    /**
     * Purpose: The type name of the Form to be used as the ErrorMessageForm
     * Notes:   The type needs to implement the
     *          Consultingwerk.Util.Forms.IErrorMessageForm interface
     */
    DEFINE PUBLIC STATIC PROPERTY ErrorMessageFormType AS CHARACTER NO-UNDO
         INITIAL "Consultingwerk.Windows.Util.Forms.ErrorMessageForm":U
    GET.
    SET.

    /**
     * Purpose: Allows to control if Table And Field information should be suppressed
     *          with messages generated by the backend.
     * Notes:
     */
    DEFINE PUBLIC STATIC PROPERTY SuppressTableAndFieldInfo AS LOGICAL INITIAL FALSE NO-UNDO
    GET.
    SET.

    /**
     * Purpose: Adds an ADM2 style formatted error message to an existing error
     *          message string
     * Notes:
     * @param pcMessage The existing message text
     * @param pcText The text of the additional message
     * @param pcField The field that the message belongs to
     * @param pcTable The table that the message belongs to
     * @return The resulting message text
     */
    METHOD PUBLIC STATIC CHARACTER AddErrorMessage (pcMessage AS CHARACTER,
                                                    pcText AS CHARACTER,
                                                    pcField AS CHARACTER,
                                                    pcTable AS CHARACTER):

        DEFINE VARIABLE iMsg     AS INTEGER   NO-UNDO.
        DEFINE VARIABLE iMsgCnt  AS INTEGER   NO-UNDO.
        DEFINE VARIABLE cMessage AS CHARACTER NO-UNDO.

        /* If one or more "raw" messages were passed (i.e., they are already in
           the delimited formatted created below), then these were returned from
           an AppServer object or other remote object. Just append them to any local
           messages. */

        IF pcText NE ? AND INDEX(pcText, CHR(4)) NE 0 THEN
          ASSIGN pcMessage = pcMessage +
            (IF pcMessage NE "":U THEN CHR(3) ELSE "":U) + pcText.

        ELSE DO:
            /* If there's no message passed, this means that a Progress ERROR-STATUS
               was detected, so we add a row for each of those messages. */

            iMsgCnt = IF pcText = ? THEN ERROR-STATUS:NUM-MESSAGES ELSE 1.

            msgLoop:
            DO iMsg = 1 TO iMsgCnt:
              IF pcText = ? THEN
              DO:
              /* When logging ERROR-STATUS messages, remove any which directly
                 reference the BUFFER-FIELD attribute; these errors are side-effects
                 of other assignment errors which should be reported to the user
                 instead. */
                cMessage = ERROR-STATUS:GET-MESSAGE(iMsg).
                IF INDEX(cMessage, "BUFFER-FIELD":U) NE 0 THEN
                    NEXT msgLoop .
              END. /* END DO IF pcText = ? */

              ASSIGN pcMessage = pcMessage +
                     (IF pcMessage NE "":U THEN CHR(3) ELSE "":U) +
                     (IF pcText = ? THEN cMessage ELSE pcText)
                     + CHR(4) + (IF pcField = ? THEN "":U ELSE pcField)
                     + CHR(4) + (IF pcTable = ? THEN "":U ELSE pcTable).
            END.   /* END DO iMsg */
        END.     /* END ELSE DO */

          RETURN pcMessage .

    END METHOD.

&IF NOT PROVERSION BEGINS "10.2" &THEN
    /**
     * Purpose: Adds the properties of the given error to the given JSON object
     * Notes:   Processes inner errors if available
     * @param poError The Error to parse
     * @param poJsonObject The JsonObject to add the error details to
     */
    METHOD PROTECTED STATIC VOID AddJsonErrorDetails (poError AS Progress.Lang.Error,
                                                      poJsonObject AS JsonObject):

        DEFINE VARIABLE oInnerExceptionJson   AS JsonObject NO-UNDO .
        DEFINE VARIABLE oJsonArray            AS JsonArray  NO-UNDO .
        DEFINE VARIABLE i                     AS INTEGER    NO-UNDO .
        DEFINE VARIABLE oMessage              AS JsonObject NO-UNDO .
        DEFINE VARIABLE oProperties           AS JsonObject NO-UNDO .
        DEFINE VARIABLE cUnrelevantProperties AS CHARACTER  NO-UNDO
            INIT "CallStack,NumMessages,Severity,InnerException,ReturnValue,Next-Sibling,Prev-Sibling,JsonDateTypeFormatter,SerializeEmptyLists,SerializeNullValues,UseSerializedTypeInformation,ListHash":U.

        poJsonObject:Add ("title":U, ErrorHelper:ErrorTitle(poError)) .
        poJsonObject:Add ("error":U, poError:GetClass():TypeName) .

        IF poError:NumMessages = 1 THEN DO:
            poJsonObject:Add ("message":U, poError:GetMessage (1)) .
            poJsonObject:Add ("messageNum":U, poError:GetMessageNum (1)) .
        END.
        ELSE DO:
            oJsonArray = NEW JsonArray () .

            IF poError:NumMessages > 1 THEN
            DO i = 1 TO poError:NumMessages:
                oMessage = NEW JsonObject () .
                oMessage:Add ("message":U, poError:GetMessage (i)) .
                oMessage:Add ("messageNum":U, poError:GetMessageNum (i)) .

                oJsonArray:Add (oMessage) .
            END.

            poJsonObject:Add ("messages":U, oJsonArray) .
        END.

        IF TYPE-OF (poError, AppError) AND CAST (poError, AppError):ReturnValue > "" THEN
            poJsonObject:Add ("returnValue":U, CAST (poError, AppError):ReturnValue) .

        IF poError:CallStack > "" THEN
            poJsonObject:Add("callStack":U, poError:CallStack) .

        IF TYPE-OF (poError, ISupportsInnerException) AND VALID-OBJECT (CAST (poError, ISupportsInnerException):InnerException) THEN DO:
            oInnerExceptionJson = NEW JsonObject () .
            poJsonObject:Add("causedBy":U, oInnerExceptionJson) .

            ErrorHelper:AddJsonErrorDetails(CAST (poError,ISupportsInnerException):InnerException, oInnerExceptionJson) .
        END.

        &IF DEFINED (AblReflection) NE 0 &THEN
        IF AblReflectionHelper:PropertyNamesExcept (poError, cUnrelevantProperties) > "":U THEN DO:
            oProperties = NEW JsonObject () .

            JsonHelper:AddObjectPropertiesToJson (poError,
                                                  oProperties,
                                                  cUnrelevantProperties) .

            poJsonObject:Add ("properties":U, oProperties) .
        END.
        &ENDIF

    END METHOD.
&ENDIF

    /**
     * Purpose: Returns a single CHARACTER string composed of the error-strings
     *          of all records (from all tables in the given Dataset instance)
     * Notes:   Method moved to DatasetHelper, kept here for backwards compability
     *          as a facade to DatasetHelper:DatasetErrorStrings
     * @param phDataset The handle of the dataset to return the error strings from
     * @return The string composed of the error-strings of all records
     */
    METHOD PUBLIC STATIC CHARACTER DatasetErrorStrings (phDataset AS HANDLE):

        RETURN DatasetHelper:DatasetErrorStrings (phDataset) .

    END METHOD .

    /**
     * Purpose: Deregisters the IErrorHandler implementation
     * Notes:
     * @param poErrorHandler The IErrorHandler to deregister
     */
    METHOD PUBLIC STATIC VOID DeRegisterErrorHandler (poErrorHandler AS IErrorHandler):

        IF NOT VALID-OBJECT (oListIErrorHandler) THEN
            RETURN .

        oListIErrorHandler:Remove (poErrorHandler) .

    END METHOD.

    /**
     * Purpose: Returns the Title associated with an error message
     * Notes:   Errors that implemnt the IErrorTitle interface return their own title
     *          For other errors, when the SmartFramework is present the type name is
     *          used as the message key when looking up translations in the "Error"
     *          translation scope.
     *          When no title could be obtained, a default title is returned from this
     *          routine
     * @param poError The reference to the error object
     * @return The title associated with the error message
     */
    METHOD PUBLIC STATIC CHARACTER ErrorTitle (poError AS Progress.Lang.Error):

        DEFINE VARIABLE cKey        AS CHARACTER NO-UNDO .
        DEFINE VARIABLE cTranslated AS CHARACTER NO-UNDO .

        /* Error that provides it's own title */
        IF TYPE-OF (poError, IErrorTitle) THEN
            RETURN CAST (poError, IErrorTitle):Title .

        /* SmartFramework Translation */
        IF VALID-OBJECT ({Consultingwerk/get-service.i Consultingwerk.SmartFramework.ITranslationProvider}) THEN DO:

&IF DEFINED (DotNetAccessible) NE 0 &THEN
            IF TYPE-OF (poError, System.Exception) THEN
                ASSIGN cKey = CAST (poError, System.Exception):GetType ():FullName .
            ELSE
&ENDIF
            ASSIGN cKey = poError:GetClass():TypeName .

            ASSIGN cTranslated = {Consultingwerk/translate.i &scope="'Error':U" &key="cKey"} .

            IF cTranslated > "":U THEN
                RETURN cTranslated .

            IF TYPE-OF (poError, Progress.Lang.AppError) THEN DO:
                ASSIGN cTranslated = {Consultingwerk/translate.i &scope="'Error':U" &key="poError:GetClass():TypeName"} .

                IF cTranslated > "":U THEN
                    RETURN cTranslated .
            END.

&IF DEFINED (DotNetAccessible) NE 0 &THEN
            IF TYPE-OF (poError, System.Exception) THEN DO:
                ASSIGN cTranslated = {Consultingwerk/translate.i &scope="'Error':U" &key="'System.Exception':U"} .

                IF cTranslated > "":U THEN
                    RETURN cTranslated .
            END.
&ENDIF
        END.

        IF TYPE-OF (poError, Progress.Lang.SysError) THEN
            RETURN "A runtime error has occurred"{&TRAN} .

        IF TYPE-OF (poError, Progress.Lang.SoapFaultError) THEN
            RETURN "A SOAP fault error has occurred"{&TRAN} .

        IF TYPE-OF (poError, Progress.Lang.AppError) THEN
            RETURN SUBSTITUTE ("An application error has occurred (&1)"{&TRAN}, poError:GetClass():TypeName) .

&IF DEFINED (DotNetAccessible) NE 0 &THEN
        IF TYPE-OF (poError, System.Exception) THEN
            RETURN SUBSTITUTE ("A .NET Exception has occurred (&1)"{&TRAN}, CAST (poError, System.Exception):GetType():FullName) .
&ENDIF

        RETURN ErrorHelper:ErrorTypeName(poError) .

    END METHOD .

    /**
     * Purpose: Returns the Typename of the error object
     * Notes:   Required as .NET Exceptions don't have an ABL Class
     *          (GetClass() returns ?)
     * @param e The Error (Progress error of .NET Exception) to return the type name for
     * @return The type name (class name) of the error object
     */
    METHOD PUBLIC STATIC CHARACTER ErrorTypeName (e AS Progress.Lang.Error):

&IF DEFINED (DotNetAccessible) NE 0 &THEN
        IF TYPE-OF (e, System.Exception) THEN
            RETURN CAST(e, System.Exception):GetType():ToString() .
        ELSE
&ENDIF
            RETURN e:GetClass():TypeName .

    END METHOD.

    /**
     * Purpose: Returns a single CHARACTER string composed of the messages
     *          Contained in the Progress.Lang.Error object
     * Notes:
     * @param poError The Progress.Lang.Error to format
     * @return A string containing all formatted messages from the Error object
     */
    METHOD PUBLIC STATIC CHARACTER FormattedErrorMessages (poError AS Progress.Lang.Error):

        DEFINE VARIABLE iMessage   AS INTEGER        NO-UNDO .
        DEFINE VARIABLE cReturn    AS CHARACTER      NO-UNDO .
        DEFINE VARIABLE cMessage   AS CHARACTER      NO-UNDO .
        DEFINE VARIABLE cEntry     AS CHARACTER      NO-UNDO .
        DEFINE VARIABLE cFormatted AS CHARACTER      NO-UNDO .
        DEFINE VARIABLE iError     AS INTEGER        NO-UNDO .
        DEFINE VARIABLE oSoapFault AS SoapFaultError NO-UNDO .

        DEFINE VARIABLE cLineEnd   AS CHARACTER      NO-UNDO INITIAL "~n":U .

        ASSIGN cLineEnd = Consultingwerk.Environment:NewLine .

        DO iError = 1 TO poError:NumMessages:

            ASSIGN cMessage = poError:GetMessage(iError).

            /* Mike Fechner, Consultingwerk Ltd. 04.07.2009
               Formatting of ADM2 Style error messages */
            IF INDEX(cMessage, CHR(4)) > 0 THEN DO:
                DO iMessage = 1 TO NUM-ENTRIES(cMessage, CHR(3)):
                    ASSIGN cEntry     = ENTRY(iMessage, cMessage, CHR(3))
                           cFormatted = ENTRY(1, cEntry, CHR(4)).

                    IF cFormatted BEGINS "SmartMessage~t":U THEN
                        cFormatted = ErrorHelper:GetSmartMessage (cFormatted) .

                    /* Mike Fechner, Consultingwerk Ltd. 06.11.2009
                       Ability to suppress Table and Field Info with Dataset Error Messages */
                    IF ErrorHelper:SuppressTableAndFieldInfo = FALSE THEN DO:
                        IF NUM-ENTRIES(cEntry, CHR(4)) > 1 AND ENTRY(2, cEntry, CHR(4)) > "":U THEN
                            ASSIGN cFormatted = cFormatted + cLineEnd + "  ":U + "Field: "{&TRAN} + ENTRY(2, cEntry, CHR(4)) .
                        IF NUM-ENTRIES(cEntry, CHR(4)) > 2 AND ENTRY(3, cEntry, CHR(4)) > "":U THEN
                            ASSIGN cFormatted = cFormatted + cLineEnd + "  ":U + "Table: "{&TRAN} + ENTRY(3, cEntry, CHR(4)) .
                    END.

                    ASSIGN cFormatted = cFormatted + cLineEnd .
                END.

                ASSIGN cMessage = cFormatted .
            END.
            ELSE IF cMessage BEGINS "SmartMessage~t":U THEN
                cMessage = ErrorHelper:GetSmartMessage (cMessage) .

            cReturn = cReturn +
                       (IF iError > 1 THEN cLineEnd ELSE "":U) +
                       cMessage .
        END.

        /* Mike Fechner, Consultingwerk Ltd. 21.10.2011
           Output SOAP-FAULT */
        IF TYPE-OF (poError, Progress.Lang.SoapFaultError) THEN DO:
            oSoapFault = CAST (poError, Progress.Lang.SoapFaultError) .

            IF VALID-HANDLE (oSoapFault:SoapFault) THEN
                cReturn = SUBSTITUTE ("&1~n~nSOAP fault: &2~nFault detail: &3~nFault code: &4~nFault Actor: &5"{&TRAN},
                                      cReturn,
                                      oSoapFault:SoapFault:SOAP-FAULT-STRING,
                                      oSoapFault:SoapFault:SOAP-FAULT-DETAIL,
                                      oSoapFault:SoapFault:SOAP-FAULT-CODE,
                                      oSoapFault:SoapFault:SOAP-FAULT-ACTOR) .
        END.

        /* Mike Fechner, Consultingwerk Ltd. 27.12.2013
           Handle ReturnValue of AppError */
        IF TYPE-OF (poError, Progress.Lang.AppError) AND CAST (poError, Progress.Lang.AppError):ReturnValue > "":U THEN
            ASSIGN cReturn = cReturn + (IF cReturn > "":U THEN cLineEnd + cLineEnd ELSE "":U) +
                                  CAST (poError, Progress.Lang.AppError):ReturnValue .

        RETURN cReturn .

    END METHOD .

    /**
     * Purpose: Returns a single CHARACTER string composed of the messages
     *          Contained in the Progress.Lang.Error object, including the stack
     *          trace and the text of inner exceptions when present
     * Notes:   Useful when logging complex error objects to a file
     * @param poError The Progress.Lang.Error to format
     * @return A string containing all formatted messages from the Error object
     */
    METHOD PUBLIC STATIC CHARACTER FormattedErrorMessagesExt (poError AS Progress.Lang.Error):

        DEFINE VARIABLE cReturn      AS CHARACTER           NO-UNDO .
        DEFINE VARIABLE iIndent      AS INTEGER             NO-UNDO .

        DEFINE VARIABLE cType        AS CHARACTER           NO-UNDO .
        DEFINE VARIABLE cMessage     AS CHARACTER           NO-UNDO .
        DEFINE VARIABLE lcStacktrace AS CHARACTER           NO-UNDO .
        DEFINE VARIABLE cPattern     AS CHARACTER           NO-UNDO INITIAL "An &1 has occurred:"{&TRAN} .

        DEFINE VARIABLE oError       AS Progress.Lang.Error NO-UNDO .

        oError = poError .

        DO WHILE VALID-OBJECT (oError) ON ERROR UNDO, THROW:

            ASSIGN cType        = ErrorHelper:ErrorTypeName (oError)
                   cMessage     = ErrorHelper:FormattedErrorMessages (oError)
                   lcStacktrace = ErrorHelper:StackTrace (oError)
                .

            IF cType > "":U THEN
                cReturn = cReturn +
                          StringHelper:Indent (SUBSTITUTE (cPattern, cType),
                                               iIndent * 5) +
                          Consultingwerk.Environment:NewLine .

            IF cMessage > "":U THEN
                cReturn = cReturn +
                          StringHelper:Indent (cMessage,
                                               iIndent * 5) +
                          Consultingwerk.Environment:NewLine .

            IF lcStacktrace > "":U THEN
                cReturn = cReturn +
                          StringHelper:Indent (lcStacktrace,
                                               iIndent * 5) +
                          Consultingwerk.Environment:NewLine .


            IF TYPE-OF (oError, ISupportsInnerException) THEN DO:
                ASSIGN oError   = CAST (oError, ISupportsInnerException):InnerException
                       iIndent  = iIndent + 1
                       cPattern = "Caused by an &1:"{&TRAN} .
            END.
            ELSE
                oError = ? .
        END.

        RETURN cReturn .

    END METHOD .

    /**
     * Purpose: Returns the text of the given ABL error message
     * Notes:   Parses the PROMSGS file
     * @param piMessageNumber The number of the error message to retrieve
     * @return The text of the error message
     */
    METHOD PUBLIC STATIC CHARACTER GetRuntimeErrorMessage (piMessageNumber AS INTEGER):

        DEFINE VARIABLE iPos     AS INTEGER   NO-UNDO .
        DEFINE VARIABLE cMessage AS CHARACTER NO-UNDO FORMAT "x(80)":U .
        DEFINE VARIABLE i        AS INTEGER   NO-UNDO .
        DEFINE VARIABLE cPromsgs AS CHARACTER NO-UNDO .

        ASSIGN cPromsgs = SessionHelper:PROMSGS .

        FileAssert:Exists (cPromsgs) .

        ASSIGN iPos = 81 + (piMessageNumber - 1) * 81 .

        INPUT FROM VALUE (cPromsgs) BINARY NO-MAP .

        SEEK INPUT TO iPos .

        DO i = 1 TO 80:
            READKEY .

            ASSIGN cMessage = cMessage + KEYFUNCTION (LASTKEY) .
        END.

        INPUT CLOSE .

        cMessage = TRIM (cMessage) .

        RETURN cMessage .

    END METHOD.

    /**
     * Purpose: Formats a SmartMessage
     * Notes:   This method is dependent on a Consultingwerk.SmartFramework.IMessageProvider
     *          implementation registered in the ServiceContainer. When there is no
     *          IMessageProvider implementation the vaue of pcSmartMessage will be
     *          returned to the caller
     * @param pcSmartMessage The smart message structure as returned by MessageFormatted class
     * @return The error message string as returned by the IMessageProvider
     */
    METHOD PUBLIC STATIC CHARACTER GetSmartMessage (pcSmartMessage AS CHARACTER):

        DEFINE VARIABLE oMessageProvider AS Consultingwerk.SmartFramework.IMessageProvider NO-UNDO .

        oMessageProvider = {Consultingwerk/get-service.i Consultingwerk.SmartFramework.IMessageProvider} .

        IF NOT VALID-OBJECT (oMessageProvider) THEN
            RETURN pcSmartMessage .

        ASSIGN pcSmartMessage = pcSmartMessage + FILL ("~t":U, 12) .

        RETURN oMessageProvider:GetMessageText (ENTRY (2, pcSmartMessage, "~t":U),
                                                INTEGER (ENTRY (3, pcSmartMessage, "~t":U)),
                                                ENTRY (4, pcSmartMessage, "~t":U),
                                                ENTRY (5, pcSmartMessage, "~t":U),
                                                ENTRY (6, pcSmartMessage, "~t":U),
                                                ENTRY (7, pcSmartMessage, "~t":U),
                                                ENTRY (8, pcSmartMessage, "~t":U),
                                                ENTRY (9, pcSmartMessage, "~t":U),
                                                ENTRY (10, pcSmartMessage, "~t":U),
                                                ENTRY (11, pcSmartMessage, "~t":U),
                                                ENTRY (12, pcSmartMessage, "~t":U)) .

    END METHOD .

    /**
     * Purpose: Handles an Error object using the registered IErrorHandler
     *          implementations
     * Notes:   Logical return value indicates if the error has been completely
     *          Handled, that is when this method returns TRUE, the ErrorHelper
     *          will not display the error anymore, returns false when the
     *          ErrorHelper should still display the error message dialog.
     * @param poError The Error object to handle
     * @return Logical value indicating of the error has been completely handled by an IErrorHandler instance
     */
    METHOD PROTECTED STATIC LOGICAL HandleError (poError AS Progress.Lang.Error):

        DEFINE VARIABLE lReturn  AS LOGICAL       NO-UNDO INITIAL FALSE .
        DEFINE VARIABLE oHandler AS IErrorHandler NO-UNDO .
        DEFINE VARIABLE i        AS INTEGER       NO-UNDO.

        IF NOT VALID-OBJECT (oListIErrorHandler) THEN
            RETURN FALSE .

        DO i = 1 TO oListIErrorHandler:Count:
            ASSIGN oHandler = oListIErrorHandler:GetItem (i) .

            IF VALID-OBJECT (oHandler) AND oHandler:HandleError (poError) = TRUE THEN
                ASSIGN lReturn = TRUE .
        END.

        RETURN lReturn .

    END METHOD.

    /**
     * Purpose: Returns if the error instance contains an error message with the given
     *          message number
     * Notes:   Returns FALSE also when poError = ?
     * @param poError The error instance to verify
     * @param piMessageNumber The message number to search for
     * @return Logical value indicating if the error contains a message with the given message number
     */
    METHOD PUBLIC STATIC LOGICAL HasMessageNumber (poError AS Progress.Lang.Error,
                                                   piMessageNumber AS INTEGER):

        DEFINE VARIABLE i AS INTEGER NO-UNDO.

        IF NOT VALID-OBJECT (poError) THEN
            RETURN FALSE .

        DO i = 1 TO poError:NumMessages:
            IF poError:GetMessageNum (i) = piMessageNumber THEN
                RETURN TRUE .
        END.

        RETURN FALSE .

    END METHOD .

    /**
     * Purpose: Ignores specific Progress.Lang.SysErrors and throws all others
     * Notes:
     * @param poError The Progress.Lang.Error instance to inspec
     * @param piErrorNum The SysError message number to ignore
     */
    METHOD PUBLIC STATIC VOID IgnoreError (poError AS Progress.Lang.Error,
                                           piErrorNum AS INTEGER):

        DEFINE VARIABLE oSysError AS Progress.Lang.SysError NO-UNDO .
        DEFINE VARIABLE i         AS INTEGER                NO-UNDO .

        IF TYPE-OF (poError, SysError) THEN DO:

            ASSIGN oSysError = CAST (poError, SysError) .

            DO i = 1 TO oSysError:NumMessages:

                IF oSysError:GetMessageNum(i) = piErrorNum THEN
                    RETURN .
            END.
        END.

        UNDO, THROW poError .

    END METHOD.

    /**
     * Purpose: Ignores specific Progress.Lang.SysErrors and throws all others
     * Notes:
     * @param poError The Progress.Lang.Error instance to inspec
     * @param piErrorNum1 The SysError message number to ignore
     * @param piErrorNum2 The SysError message number to ignore
     */
    METHOD PUBLIC STATIC VOID IgnoreError (poError AS Progress.Lang.Error,
                                           piErrorNum1 AS INTEGER,
                                           piErrorNum2 AS INTEGER):

        DEFINE VARIABLE oSysError AS Progress.Lang.SysError NO-UNDO .
        DEFINE VARIABLE i         AS INTEGER                NO-UNDO .

        IF TYPE-OF (poError, SysError) THEN DO:

            ASSIGN oSysError = CAST (poError, SysError) .

            DO i = 1 TO oSysError:NumMessages:

                IF oSysError:GetMessageNum(i) = piErrorNum1 OR
                   oSysError:GetMessageNum(i) = piErrorNum2 THEN
                    RETURN .
            END.
        END.

        UNDO, THROW poError .

    END METHOD.

    /**
     * Purpose: Ignores specific Progress.Lang.SysErrors and throws all others
     * Notes:
     * @param poError The Progress.Lang.Error instance to inspec
     * @param piErrorNum1 The SysError message number to ignore
     * @param piErrorNum2 The SysError message number to ignore
     * @param piErrorNum3 The SysError message number to ignore
     */
    METHOD PUBLIC STATIC VOID IgnoreError (poError AS Progress.Lang.Error,
                                           piErrorNum1 AS INTEGER,
                                           piErrorNum2 AS INTEGER,
                                           piErrorNum3 AS INTEGER):

        DEFINE VARIABLE oSysError AS Progress.Lang.SysError NO-UNDO .
        DEFINE VARIABLE i         AS INTEGER                NO-UNDO .

        IF TYPE-OF (poError, SysError) THEN DO:

            ASSIGN oSysError = CAST (poError, SysError) .

            DO i = 1 TO oSysError:NumMessages:

                IF oSysError:GetMessageNum(i) = piErrorNum1 OR
                   oSysError:GetMessageNum(i) = piErrorNum2 OR
                   oSysError:GetMessageNum(i) = piErrorNum3 THEN
                    RETURN .
            END.
        END.

        UNDO, THROW poError .

    END METHOD.

    /**
     * Purpose: Ignores specific Progress.Lang.SysErrors and throws all others
     * Notes:
     * @param poError The Progress.Lang.Error instance to inspec
     * @param piErrorNum1 The SysError message number to ignore
     * @param piErrorNum2 The SysError message number to ignore
     * @param piErrorNum3 The SysError message number to ignore
     * @param piErrorNum4 The SysError message number to ignore
     */
    METHOD PUBLIC STATIC VOID IgnoreError (poError AS Progress.Lang.Error,
                                           piErrorNum1 AS INTEGER,
                                           piErrorNum2 AS INTEGER,
                                           piErrorNum3 AS INTEGER,
                                           piErrorNum4 AS INTEGER):

        DEFINE VARIABLE oSysError AS Progress.Lang.SysError NO-UNDO .
        DEFINE VARIABLE i         AS INTEGER                NO-UNDO .

        IF TYPE-OF (poError, SysError) THEN DO:

            ASSIGN oSysError = CAST (poError, SysError) .

            DO i = 1 TO oSysError:NumMessages:

                IF oSysError:GetMessageNum(i) = piErrorNum1 OR
                   oSysError:GetMessageNum(i) = piErrorNum2 OR
                   oSysError:GetMessageNum(i) = piErrorNum3 OR
                   oSysError:GetMessageNum(i) = piErrorNum4 THEN
                    RETURN .
            END.
        END.

        UNDO, THROW poError .

    END METHOD.

    /**
     * Purpose: Ignores specific Progress.Lang.SysErrors and throws all others
     * Notes:
     * @param poError The Progress.Lang.Error instance to inspec
     * @param piErrorNum1 The SysError message number to ignore
     * @param piErrorNum2 The SysError message number to ignore
     * @param piErrorNum3 The SysError message number to ignore
     * @param piErrorNum4 The SysError message number to ignore
     * @param piErrorNum5 The SysError message number to ignore
     */
    METHOD PUBLIC STATIC VOID IgnoreError (poError AS Progress.Lang.Error,
                                           piErrorNum1 AS INTEGER,
                                           piErrorNum2 AS INTEGER,
                                           piErrorNum3 AS INTEGER,
                                           piErrorNum4 AS INTEGER,
                                           piErrorNum5 AS INTEGER):

        DEFINE VARIABLE oSysError AS Progress.Lang.SysError NO-UNDO .
        DEFINE VARIABLE i         AS INTEGER                NO-UNDO .

        IF TYPE-OF (poError, SysError) THEN DO:

            ASSIGN oSysError = CAST (poError, SysError) .

            DO i = 1 TO oSysError:NumMessages:

                IF oSysError:GetMessageNum(i) = piErrorNum1 OR
                   oSysError:GetMessageNum(i) = piErrorNum2 OR
                   oSysError:GetMessageNum(i) = piErrorNum3 OR
                   oSysError:GetMessageNum(i) = piErrorNum4 OR
                   oSysError:GetMessageNum(i) = piErrorNum5 THEN
                    RETURN .
            END.
        END.

        UNDO, THROW poError .

    END METHOD.

&IF NOT PROVERSION BEGINS "10.2" &THEN
    /**
     * Purpose: Returns a Json Object with the error details
     * Notes:   Processes inner errors if available
     * @param poError The Error to parse
     * @return The JsonObject describing the error
     */
    METHOD PUBLIC STATIC JsonObject JsonErrorDetails (poError AS Progress.Lang.Error):

        DEFINE VARIABLE oJsonObject AS JsonObject NO-UNDO .

        oJsonObject = NEW JsonObject () .

        ErrorHelper:AddJsonErrorDetails (poError, oJsonObject) .

        RETURN oJsonObject .

    END METHOD.
&ENDIF

    /**
     * Purpose: Parses an 132 runtime Error and returns the table and field/values
     *          (** Salesrep already exists with Sales Rep "bbb". (132))
     * Notes:
     * @param poError The SysError to parse
     * @return The Error132Info with the details about the error
     */
    METHOD PUBLIC STATIC Error132Info ParseError132 (poError AS Progress.Lang.SysError):

        DEFINE VARIABLE cDefault AS CHARACTER NO-UNDO .
        DEFINE VARIABLE cMessage AS CHARACTER NO-UNDO .
        DEFINE VARIABLE iStart   AS INTEGER   NO-UNDO .
        DEFINE VARIABLE iEnd     AS INTEGER   NO-UNDO .
        DEFINE VARIABLE cMiddle  AS CHARACTER NO-UNDO .
        DEFINE VARIABLE iMiddle  AS INTEGER   NO-UNDO .

        Assert:Equals (132, poError:GetMessageNum (1)) .

        ASSIGN cMessage = poError:GetMessage (1)
               cDefault = ErrorHelper:GetRuntimeErrorMessage (132) .

        ASSIGN iStart = INDEX (cDefault, "%s":U)
               iEnd   = INDEX (cDefault, "%s":U, iStart + 2)
               cMiddle = SUBSTRING (cDefault, iStart + 2, iEnd - iStart - 2, "CHARACTER":U)
               iMiddle = INDEX (cMessage, cMiddle).

        RETURN NEW Error132Info (TRIM (SUBSTRING (cMessage, iStart, iMiddle - iStart, "CHARACTER":U)),
                                 TRIM (SUBSTRING (cMessage,
                                                  iMiddle + LENGTH (cMiddle, "CHARACTER":U),
                                                  LENGTH (cMessage, "CHARACTER":U) - iMiddle - LENGTH (cMiddle, "CHARACTER":U) - (LENGTH (cDefault, "CHARACTER":U) - iEnd) + 2,
                                                  "CHARACTER":U))).

    END METHOD.

    /**
     * Purpose: Registers a new IErrorHandler implementation
     * Notes:
     * @param poErrorHandler The reference to the IErrorHandler to register
     */
    METHOD PUBLIC STATIC VOID RegisterErrorHandler (poErrorHandler AS IErrorHandler):

        IF NOT VALID-OBJECT (oListIErrorHandler) THEN DO:
            oListIErrorHandler = NEW ListIErrorHandler () .
        END.

        oListIErrorHandler:Add (poErrorHandler) .

    END METHOD.

    /**
     * Purpose: Resets the ERROR-STATUS:ERROR and ERROR-STATUS:NUM-MESSAGES etc.
     * Notes:   Useful to wipe pending error stati and messages after executing ABL
     *          code with NO-ERROR
     */
    METHOD PUBLIC STATIC VOID ResetErrorStatus ():

        ERROR-STATUS:ERROR = FALSE NO-ERROR .

    END METHOD.

    /**
     * Purpose: Display Error Message
     * Notes:   Error Type (Class) will be used a default title
     * @param err The Error object to visualize
     */
    METHOD PUBLIC STATIC VOID ShowErrorMessage (err AS Progress.Lang.Error):

        DEFINE VARIABLE cTitle AS CHARACTER NO-UNDO.

&IF DEFINED (DotNetAccessible) NE 0 &THEN
        IF cStackTrace = "":U THEN
            ASSIGN cStackTrace = ErrorHelper:CurrentStacktrace .

        /* Mike Fechner, Consultingwerk Ltd. 27.12.2009
           Delegate to ShowErrorMessageBox */
        IF NOT ErrorHelper:ErrorMessageDialogAllowed THEN DO:
           ErrorHelper:ShowErrorMessageBox (err) .
           RETURN .
        END.

        ASSIGN cTitle = ErrorTitle (err) .

        ErrorHelper:ShowErrorMessage (err, cTitle, ?) .
&ELSE
        IF cStackTrace = "":U THEN
            ASSIGN cStackTrace = ErrorHelper:CurrentStacktrace .

        ErrorHelper:ShowErrorMessageBox (err) .
&ENDIF

        FINALLY:
            ASSIGN cStackTrace = "":U .
        END FINALLY.

    END METHOD.

    /**
     * Purpose: Display Error Message
     * Notes:   Stacktrack will be displayed when FrameworkSettings:DebugMode = TRUE
     * @param e The Error object to visualize
     * @param pcTitle The title for the message message (dialog)
     */
    METHOD PUBLIC STATIC VOID ShowErrorMessage (e AS Progress.Lang.Error,
                                                pcTitle AS CHARACTER):


&IF DEFINED (DotNetAccessible) NE 0 &THEN
        ErrorHelper:ShowErrorMessage (e, pcTitle, ?) .
&ELSE
        IF cStackTrace = "":U THEN
            ASSIGN cStackTrace = ErrorHelper:CurrentStacktrace .

        ErrorHelper:ShowErrorMessageBox (e, pcTitle) .

        FINALLY:
            ASSIGN cStackTrace = "":U .
        END FINALLY.
&ENDIF

    END METHOD .

&IF DEFINED (DotNetAccessible) NE 0 &THEN
    /**
     * Purpose: Display Error Message
     * Notes:   Stacktrack will be displayed when FrameworkSettings:DebugMode = TRUE
     * @param e The Error object to visualize
     * @param poParentForm The ParentForm
     */
    METHOD PUBLIC STATIC VOID ShowErrorMessage (e AS Progress.Lang.Error,
                                                poParentForm AS System.Windows.Forms.Form):

        DEFINE VARIABLE cTitle AS CHARACTER NO-UNDO.

        IF cStackTrace = "":U THEN
            ASSIGN cStackTrace = ErrorHelper:CurrentStacktrace .

        /* Mike Fechner, Consultingwerk Ltd. 27.12.2009
           Delegate to ShowErrorMessageBox */
        IF NOT ErrorHelper:ErrorMessageDialogAllowed THEN DO:
           ErrorHelper:ShowErrorMessageBox (e) .
           RETURN .
        END.

        ASSIGN cTitle = ErrorTitle (e) .

        ErrorHelper:ShowErrorMessage (e, cTitle, poParentForm) .

        FINALLY:
            ASSIGN cStackTrace = "":U .
        END FINALLY.

    END METHOD .

    /**
     * Purpose: Display Error Message
     * Notes:   Stacktrack will be displayed when FrameworkSettings:DebugMode = TRUE
     * @param e The Error object to visualize
     * @param pcTitle The title for the message message (dialog)
     * @param poParentForm The ParentForm
     */
    METHOD PUBLIC STATIC VOID ShowErrorMessage (e AS Progress.Lang.Error,
                                                pcTitle AS CHARACTER,
                                                poParentForm AS System.Windows.Forms.Form):

        DEFINE VARIABLE cErrorString       AS CHARACTER                                      NO-UNDO .
        DEFINE VARIABLE oMessageForm       AS Consultingwerk.Util.Forms.IErrorMessageForm    NO-UNDO .
        DEFINE VARIABLE oForm              AS System.Windows.Forms.Form                      NO-UNDO .

        IF cStackTrace = "":U THEN
            ASSIGN cStackTrace = ErrorHelper:CurrentStacktrace .

        /* Mike Fechner, Consultingwerk Ltd. 31.03.2011
           Bug 2624: Custom Error Handlers */
        IF Consultingwerk.Util.ErrorHelper:HandleError (e) = TRUE THEN
            RETURN .

        /* Mike Fechner, Consultingwerk Ltd. 19.06.2013
           Support for IDoNotShowException */
        IF TYPE-OF (e, IDoNotShowException) THEN
            RETURN .

        /* Mike Fechner, Consultingwerk Ltd. 27.12.2009
           Delegate to ShowErrorMessageBox */
        IF NOT ErrorHelper:ErrorMessageDialogAllowed THEN DO:
           ErrorHelper:ShowErrorMessageBox (e, pcTitle) .
           RETURN .
        END.

        ASSIGN cErrorString = ErrorHelper:FormattedErrorMessages (e) .

        /* Mike Fechner, Consultingwerk Ltd. 14.07.2009
           If no error string was given, use the error class name as fall back */
        IF cErrorString > "":U THEN .
        ELSE
            cErrorString = ErrorHelper:ErrorTypeName(e) .

        DO ON ERROR UNDO, THROW:
            /* Mike Fechner, Consultingwerk Ltd. 16.07.2009
               Try display of GUI for .NET Message Dialog (will fail when run with
               function / non void method in call stack) */
            IF ErrorHelper:ErrorMessageFormType > "":U THEN
                oMessageForm = DYNAMIC-NEW (ErrorHelper:ErrorMessageFormType) () .
            ELSE
                oMessageForm = NEW Consultingwerk.Windows.Util.Forms.ErrorMessageForm () .

            oMessageForm:MessageText = cErrorString .

            oMessageForm:StackTraceText = ErrorHelper:StackTrace(e) .

            IF TYPE-OF (e, Consultingwerk.Exceptions.ISupportsInnerException) AND
               TYPE-OF (oMessageForm, ISupportsInnerExceptionDisplay) THEN

                 CAST (oMessageForm, ISupportsInnerExceptionDisplay):InnerException = CAST (e, Consultingwerk.Exceptions.ISupportsInnerException):InnerException.

            IF TYPE-OF (oMessageForm, ISupportsExceptionDisplay) THEN
                 CAST (oMessageForm, ISupportsExceptionDisplay):Exception = e.

            oForm = CAST(CAST(oMessageForm, Progress.Lang.Object), System.Windows.Forms.Form) .

            oForm:Text = pcTitle.

            IF VALID-OBJECT (poParentForm) THEN
                WAIT-FOR oForm:ShowDialog (poParentForm) .
            ELSE
                WAIT-FOR oForm:ShowDialog ()  .

            CATCH e AS Progress.Lang.Error :
                IF FrameworkSettings:DebugMode = FALSE THEN
                    MESSAGE cErrorString
                        VIEW-AS ALERT-BOX ERROR TITLE pcTitle .
                ELSE
                    MESSAGE cErrorString SKIP (2)
                            "Stacktrace:"{&TRAN} SKIP (1)
                            ErrorHelper:StackTrace(e)
                        VIEW-AS ALERT-BOX ERROR TITLE pcTitle .

                MESSAGE e:GetMessage(1)
                    VIEW-AS ALERT-BOX ERROR TITLE "Error"{&TRAN} .

            END CATCH.
        END.

        /* Marko Rüterbories, Consultingwerk Ltd. 06.08.2009
           Bug 1973: Dialogs (ABL extended .NET Objects) are not garbage collected if the
                     references are not programaticaly deleted (DELETE OBJECT or Dispose ()). */
        FINALLY:
            IF VALID-OBJECT (oMessageForm) THEN
                DELETE OBJECT oMessageForm.

            ASSIGN cStackTrace = "":U .
        END FINALLY.

    END METHOD.
&ENDIF

    /**
     * Purpose: Display Error Message as an alert-box (to be used in functions
     *          and non-void methods due to WAIT-FOR limitations)
     * Notes:   Stacktrack will be displayed when FrameworkSettings:DebugMode = TRUE
     * @param e The Error object to visualize
     * @param pcTitle The title for the message message (dialog)
     */
    METHOD PUBLIC STATIC VOID ShowErrorMessageBox (e AS Progress.Lang.Error,
                                                   pcTitle AS CHARACTER):

        DEFINE VARIABLE cErrorString AS CHARACTER NO-UNDO.

        IF cStackTrace = "":U THEN
            ASSIGN cStackTrace = ErrorHelper:CurrentStacktrace .

        /* Mike Fechner, Consultingwerk Ltd. 31.03.2011
           Bug 2624: Custom Error Handlers */
        IF Consultingwerk.Util.ErrorHelper:HandleError (e) THEN
            RETURN .

        /* Mike Fechner, Consultingwerk Ltd. 19.06.2013
           Support for IDoNotShowException */
        IF TYPE-OF (e, IDoNotShowException) THEN
            RETURN .

        ASSIGN cErrorString = ErrorHelper:FormattedErrorMessages (e) .

        IF TYPE-OF (e, Progress.Lang.AppError) AND CAST (e, Progress.Lang.AppError):ReturnValue > "":U THEN
            ASSIGN cErrorString = cErrorString + (IF cErrorString > "":U THEN "~n~n":U ELSE "":U) +
                                  CAST (e, Progress.Lang.AppError):ReturnValue .

        /* Mike Fechner, Consultingwerk Ltd. 14.07.2009
           If no error string was given, use the error class name as fall back */
        IF cErrorString > "":U THEN .
        ELSE cErrorString = ErrorHelper:ErrorTypeName(e) .

        IF FrameworkSettings:DebugMode THEN
            MESSAGE cErrorString SKIP(2)
                    ErrorHelper:StackTrace (e)
               VIEW-AS ALERT-BOX ERROR TITLE pcTitle .
        ELSE
            MESSAGE cErrorString
               VIEW-AS ALERT-BOX ERROR TITLE pcTitle .

        FINALLY:
            ASSIGN cStackTrace = "":U .
        END FINALLY.

    END METHOD.

    /**
     * Purpose: Display Error Message as an alert-box (to be used in functions
     *          and non-void methods due to WAIT-FOR limitations)
     * Notes:   Error Type (Class) will be used a default title
     * @param e The Error object to visualize
     */
    METHOD PUBLIC STATIC VOID ShowErrorMessageBox (e AS Progress.Lang.Error):

        DEFINE VARIABLE cTitle AS CHARACTER NO-UNDO.

        IF cStackTrace = "":U THEN
            ASSIGN cStackTrace = ErrorHelper:CurrentStacktrace .

        ASSIGN cTitle = ErrorTitle (e) .

        ErrorHelper:ShowErrorMessageBox (e, cTitle) .

        FINALLY:
            ASSIGN cStackTrace = "":U .
        END FINALLY.

    END METHOD.

    /**
     * Purpose: Reformats the Error Stack Trace (most current code block first,
     *          not last as provided by the CallStack attribute
     * Notes:
     * @param e The error object to return the formatted stacktrace for
     * @return The formatted stack trace
     */
    METHOD PUBLIC STATIC LONGCHAR StackTrace (e AS Progress.Lang.Error):

        DEFINE VARIABLE cReturn AS CHARACTER NO-UNDO.

        IF e:CallStack > "":U THEN
            ASSIGN cReturn = e:CallStack .
        ELSE
            cReturn =  "Stacktrace not provided (-errorstack missing)."{&TRAN} + CHR(10) .

&IF DEFINED (DotNetAccessible) NE 0 &THEN
        IF TYPE-OF(e, System.Exception) THEN
            ASSIGN cReturn = cReturn + CHR(10) + CHR(10) +
                             ".NET Stack Trace:"{&TRAN} + CHR(10) +
                             CAST(e, System.Exception):StackTrace .
&ENDIF

        IF cStackTrace > "":U THEN
            ASSIGN cReturn = cReturn + CHR(10) + CHR(10) +
                             "Shown by:"{&TRAN} + CHR(10) +
                             cStackTrace .

        RETURN TRIM(cReturn, CHR(10)) .

    END METHOD.

 END CLASS.
