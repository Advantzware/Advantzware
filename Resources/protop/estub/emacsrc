;	EMACS.RC	Standard micro startup program
;			for MicroEMACS 3.10e and above
;			(C)opyright 1987 by Daniel M Lawrence
;			Last Update: 10/20/87
;
; 04/07/91	3.10 & SCO Xenix
; 08/29/00	5.03 & Linux
;

print "[Setting up...]"

set $discmd TRUE
set $ssave  TRUE
;set $palette KEYMAP FND [3~

set $fillcol 75
set %printer "lpr"

bind-to-key delete-next-character       ^?      ; character under cursor
bind-to-key delete-previous-character   ^H      ; character behind cursor
bind-to-key search-forward              ^F      ; find
bind-to-key hunt-forward                M-f     ; find next
;bind-to-key set-mark                   ^@      ; mark text to copy/cut/modify
bind-to-key clear-and-redraw            ^W      ; refresh screen
bind-to-key copy-region                 ^C      ; copy
bind-to-key kill-region                 ^X^C    ; cut marked text
bind-to-key kill-to-end-of-line         ^Y      ; delete to end of line
bind-to-key quote-character             ^O      ; alternate for ^Q, a troublesome character
bind-to-key query-replace-string        M-^R    ; search & replace with query
bind-to-key quick-exit                  ^Z      ; save all buffers & exit
bind-to-key save-file                   ^XS     ; save file (don't exit)
bind-to-key save-file                   ^Xs     ; save file (don't exit)
bind-to-key yank                        ^P      ; paste

bind-to-key describe-bindings           ^X:
bind-to-key describe-key                ^X?

bind-to-key execute-command-line	M-^C	; execute emacs commands directly
bind-to-key exit-emacs			M-x	; exit without saving anything
bind-to-key exit-emacs			M-X	; exit without saving anything
bind-to-key format-paragraph		M-^P	; beautify text
bind-to-key begin-macro			M-(	; F10 - start recording keyboard macro
bind-to-key end-macro			M-)	; F11 - end recording keyboard macro
bind-to-key execute-macro		^R	; F12 - playback keyboard macro
bind-to-key execute-macro		^XE	; playback keyboard macro

bind-to-key execute-macro-9		^V	; remove two chars and move down
bind-to-key delete-next-character       FNd	; delete
bind-to-key execute-macro-12		FNI	; insert
bind-to-key execute-macro-14		M-P	; print buffer

; Arrow Keys -------------------------------------------

bind-to-key previous-line		FNp	; up
bind-to-key next-line			FNn	; down
bind-to-key forward-character		FNf	; right
bind-to-key backward-character		FNb	; left

; Function Keys ----------------------------------------
bind-to-key set-mark			FN1	; F1  - select
bind-to-key copy-region			FN2	; F2  - copy
bind-to-key kill-region			FN3	; F3  - cut
bind-to-key yank			FN4	; F4  - paste
bind-to-key beginning-of-line		FN5	; F5  - go to start of line
bind-to-key execute-macro-11		FN6	; F6  - delete line
bind-to-key kill-to-end-of-line		FN7	; F7  - delete to end of line
bind-to-key end-of-line			FN8	; F8  - go to end of line
bind-to-key next-buffer			FN9	; F9  - go to next buffer
bind-to-key begin-macro			FNA	; F10 - start recording keyboard macro
bind-to-key end-macro			FNB	; F11 - end recording keyboard macro
bind-to-key execute-macro		FNC	; F12 - playback keyboard macro

; delete 2 characters and move down

9	store-macro
	delete-next-character
	delete-next-character
	next-line
!endm

; delete-line   ---------------------   Macro #11
11	store-macro
	beginning-of-line
	set-mark
	next-line
	kill-region
!endm

; toggle insert mode on & off   ---------------------   Macro #12
12	store-macro
	add-mode "OVER"
	set $discmd FALSE
	bind-to-key execute-macro-13	FNI
	set $discmd TRUE
!endm

; toggle insert mode on & off   ---------------------   Macro #13
13	store-macro
	delete-mode "OVER"
	set $discmd FALSE
	bind-to-key execute-macro-12	FNI
	set $discmd TRUE
!endm

; print buffer   ---------------------   Macro #14
14	store-macro
	write-message "Printing..."
	set $discmd FALSE
	set %old-buf $cbufname
	set %old-row $curline
	set %old-col $curcol
	beginning-of-file
	set-mark
	end-of-file
	copy-region
	select-buffer xprint-buffer
	yank
	unmark-buffer
	filter-buffer %printer
	unmark-buffer
	select-buffer %old-buf
	delete-buffer xprint-buffer
	goto-line %old-row
	set $curcol %old-col
	set $discmd TRUE
!endm
