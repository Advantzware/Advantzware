        1   /* lib/discover.p
        2    *
        3    * discover running databases
        4    *
        5    * use "find" to identify *.db files, confirm that they are running Progress databases with "mbpro dbname -p lib/quit.p"
        6    *
        7    *
        8    */
        9   
       10   
       11   /* lib/v9.i
       12    *
       13    */
       14   
       15   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) < 10.0 &THEN
       16   &global-define  CPYLOB  "no"
       17   &global-define  NOW     substitute( "&1 &2", today, string( time, "hh:mm:ss" ))
       18   &global-define  LNGCR   character
       19   &global-define  DTZ     integer
       20   &global-define  BIGINT  decimal
       21   &ELSE
       22   &global-define  OE10    "yes"
       23   &global-define  NOW     now
       24   &global-define  LNGCR   longchar
       25   &global-define  DTZ     datetime-tz
       26   &global-define  BIGINT  int64
       27   &ENDIF
       28    
       29   
       30   /* lib/tt_dblist.i
       31    *
       32    */
       33   
       34   define temp-table tt_dbList no-undo
       35     field xvalid        as logical
       36     field friendlyName  as character format "x(20)"
       37     field dbPath        as character format "x(60)" /* "x(128)" view-as fill-in size 60 by 1 */
       38     field serverName    as character format "x(20)" /* "x(128)" view-as fill-in size 20 by 1 */
       39     field dlcPath       as character format "x(20)" /* "x(128)" view-as fill-in size 20 by 1 */
       40     field monitorDB     as logical                  label "Mon?"
       41     field resrcType     as character format "x(10)" label "Type"
       42     field monitorPID    as character format "x(10)" label "PID"
       43     field monitorStat   as character format "x(20)" label "Status"
       44     field statusInfo    as character format "x(50)" label "Status Info"
       45   &IF DEFINED( OE10 ) &THEN
       46     field dbAlert      as datetime-tz
       47   &ELSE
       48     field dbAlert      as integer
       49   &ENDIF
       50     index friendlyName-idx is primary unique friendlyName
       51   .
       52   
       53    
       54   
       55   define input  parameter p1 as character no-undo.
       56   define output parameter table for tt_dbList.
       57   
       58   define new global shared variable logLevel as integer no-undo initial 5.
       59   
       60   define variable i        as integer no-undo.
       61   define variable n        as integer no-undo.
       62   define variable ok       as logical no-undo.
       63   define variable dupName  as logical no-undo.
       64   define variable inLine   as character no-undo format "x(30)".
       65   define variable xdbName  as character no-undo format "x(20)".
       66   define variable xdbPath  as character no-undo format "x(50)".
       67   define variable dirList  as character no-undo format "x(50)".
       68   define variable dName    as character no-undo format "x(50)".
       69   define variable srvName  as character no-undo.
       70   define variable xquit    as character no-undo.
       71   define variable dirSep   as character no-undo.
       72   define variable xeditor  as character no-undo.
       73   
       74   define stream inStrm.
       75   define stream inStrm2.
       76   
       77   if opsys = "unix" then
       78     dirSep = "/".
       79    else
       80     dirSep = "~\".
       81   
       82   if p1 = "" or p1 = ? then p1 = "/".
       83   p1 = replace( p1, ",", " " ).
       84   
       85   publish "logMsg" ( 0, substitute( "&1: &2", "lib/discover", p1 )).
       86   
       87   n = num-entries( p1, " " ).
       88   do i = 1 to n:
       89   
       90     dName = entry( i, p1, " " ).
       91   
       92     if opsys begins "win" then
       93       do:
       94         dName = dName + "~\*.db".
       95       end.
       96   
       97     dirList = substitute( "&1 &2", dirList, dName ).
       98   
       99   end.
      100   
      101   dirList = trim( dirList ).
      102   
      103   /*** ***/
      104   
      105   if dirList = "" or dirList = ? then dirList = "/".
      106   
      107   if opsys = "unix" then
      108     do:
      109       input stream inStrm through value( "uname -a" ).
      110       import stream inStrm ^ srvName.
      111       input stream inStrm close.
      112     end.
      113    else
      114     do:
      115       input stream inStrm through value( "hostname" ).
      116       import stream inStrm srvName.
      117       input stream inStrm close.
      118     end.
      119   
      120   publish "logMsg" ( 0, substitute( "&1: srvName = &2", "lib/discover", srvName )).
      121   
      122   /* get the initial, known values from etc/dblist.cfg
      123    */
      124   
      125   run lib/readdblist.p ( output table tt_dbList by-reference ).           /*** if we only discover when this doesn't exist... ***/
      126   
      127   message "Searching " replace( dirList, " ", "," ) "for .db files.".
      128   message "This may take some time...".
      129   
      130   if opsys = "unix" then
      131     input stream inStrm through value( substitute( 'find &1 -name "*.db" 2>/dev/null', dirList )).
      132    else
      133     input stream inStrm through value( substitute( 'dir /s /b &1 2>NUL', dirList )).
      134   
      135     /* input stream inStrm through value( substitute( 'find &1 -name "*.db" 2>NUL',       dirList )). */
      136   
      137   repeat:
      138   
      139     xdbPath = "".
      140     import stream inStrm unformatted xdbPath.
      141   
      142     publish "logMsg" ( 0, substitute( "&1: candidate = &2", "lib/discover", xdbPath )).
      143   
      144     file-info:file-name = replace( xdbPath, ".db", ".lk" ).
      145   
      146     if file-info:full-pathname = ? then                                   /* this might be a running Progress database    */
      147       do:
      148         publish "logMsg" ( 0, substitute( "&1: no .lk found &2, therefore not a running Progress db", "lib/discover", xdbPath )).
      149       end.
      150      else
      151       do:
      152   
      153         publish "logMsg" ( 0, substitute( "&1: .lk found &2", "lib/discover", xdbPath )).
      154   
      155         xdbPath = replace( file-info:full-pathname, ".lk", "" ).
      156   
      157         /* "** The database /db/s2k is in use in multi-user mode. (276)"  */
      158   
      159         /* useless -- proutil reports stale l.lk files as "in use..."
      160          *
      161          * input stream inStrm2 through value( substitute( 'proutil &1 -C busy', xdbPath )).
      162          *
      163          */
      164   
      165         /* There is no server for database /db/s2k. (1423)        */
      166         /* connected: /db/s2k                                     */
      167   
      168         ok = no.
      169   
      170         if opsys  = "unix" then
      171           input stream inStrm2 through value( substitute(    '$DLC/bin/_progres -b &1 -p lib/quit.p 2>/dev/null', xdbPath )).
      172          else
      173           input stream inStrm2 through value( substitute( '%DLC%~\bin~\_progres -b &1 -p lib/quit.p 2>NUL', xdbPath )).
      174   
      175         mpro_loop: repeat:
      176   
      177           import stream inStrm2 unformatted xquit.
      178   
      179           if xquit = trim( substitute( "connected: &1", xdbPath )) then
      180             do:
      181               ok = yes.
      182               leave mpro_loop.
      183             end.
      184   
      185         end.
      186   
      187         input stream inStrm2 close.
      188   
      189         if ok = yes then
      190           publish "logMsg" ( 0, substitute( "&1: &2 is a running Progress db", "lib/discover", xdbPath )).
      191          else
      192           publish "logMsg" ( 0, substitute( "&1: &2 is NOT a running Progress db, connection attempt failed", "lib/discover", xdbPath )).
      193   
      194         if ok = yes then
      195           do:
      196   
      197             assign
      198               i = 0
      199               xdbName = entry( num-entries( xdbPath, dirSep ), xdbPath, dirSep )
      200             .
      201   
      202             create_dbList: do while true:
      203               i = i + 1.
      204               find tt_dbList where tt_dbList.friendlyName = xdbName no-error.
      205               if available( tt_dbList ) then
      206                 do:
      207                   dupName = yes.
      208                   xdbName = xdbName + string( i, "_9999" ).
      209                 end.
      210                else
      211                 do:
      212                   create tt_dbList.
      213                   assign
      214                     tt_dbList.friendlyName = xdbName
      215                     tt_dbList.dbPath       = xdbPath
      216                     tt_dbList.serverName   = srvName
      217                     tt_dbList.monitorDB    = yes
      218                     tt_dbList.dlcPath      = os-getenv( "DLC" )
      219                   .
      220                   if tt_dbList.dlcPath = ? then tt_dbList.dlcPath = "".
      221                   leave create_dbList.
      222                 end.
      223   
      224             end.
      225   
      226           end.
      227         
      228       end.
      229   
      230   end.
      231   
      232   input stream inStrm close.
      233   
      234   assign
      235     i = 0
      236     n = 0
      237   .
      238   
      239   for each tt_dbList:
      240     if xvalid = yes then
      241       i = i + 1.
      242      else
      243       n = n + 1.
      244   end.
      245   
      246   run lib/editdblist.p ( input-output table tt_dbList by-reference ).
      247   
      248   n = 0.
      249   for each tt_dbList:
      250     n = n + 1.
      251   end.
      252   
      253   if n > 0 then
      254     run lib/writedblist.p ( input table tt_dblist by-reference ).
      255   
      256   if n > 0 and dupName = yes and session:batch = no then
      257     do:
      258   
      259       xeditor = os-getenv( "EDITOR" ).
      260   
      261       if xeditor = ? or xeditor = "" then
      262         xeditor = ( if opsys = "unix" then "vi" else "notepad" ).
      263   
      264       message
      265           skip(1)
      266           "You may have some awkwardly named databases - would you like to edit them?"
      267           skip(1)
      268         view-as alert-box question buttons yes-no-cancel
      269         title " Edit friendly names? "
      270         update ok
      271       .
      272   
      273       if  ok = yes then
      274         publish "logMsg" ( 0, substitute( "&1: awkward names found, editing with &2", "lib/discover", xeditor )).
      275        else
      276         publish "logMsg" ( 0, substitute( "&1: awkward names found but not editing", "lib/discover" )).
      277   
      278       if  ok = yes then
      279         do:
      280           os-command silent value( xeditor + " etc" + dirSep + "dblist.cfg" ).
      281           for each tt_dbList:
      282             delete tt_dbList.
      283           end.
      284           run lib/readdblist.p ( output table tt_dbList by-reference ).           /* get an accurate tt_dbList after manual updates       */
      285         end.
      286   
      287     end.
      288   
      289   return.
