        1   /* lib/ptsrv.p
        2    *
        3    */
        4   
        5   
        6   /* lib/v9.i
        7    *
        8    */
        9   
       10   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) < 10.0 &THEN
       11   &global-define  CPYLOB  "no"
       12   &global-define  NOW     substitute( "&1 &2", today, string( time, "hh:mm:ss" ))
       13   &global-define  LNGCR   character
       14   &global-define  DTZ     integer
       15   &global-define  BIGINT  decimal
       16   &ELSE
       17   &global-define  OE10    "yes"
       18   &global-define  NOW     now
       19   &global-define  LNGCR   longchar
       20   &global-define  DTZ     datetime-tz
       21   &global-define  BIGINT  int64
       22   &ENDIF
       23    
       24   
       25   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.2 &THEN
       26   &global-define  BIGINT  int64
       27   &ELSE
       28   &global-define  BIGINT  decimal
       29   &ENDIF
       30   
       31   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.2 AND PROVERSION >= "10.2B" &THEN
       32   &global-define  SINIT   "JSON"
       33   &ELSE
       34   &global-define  SINIT   "XML"
       35   &ENDIF
       36   
       37   &IF DEFINED( OE10 ) = 0 &THEN
       38   define new global shared temp-table tt_dataset no-undo
       39     field ttHandle as handle
       40   .
       41   &ENDIF
       42   
       43   define new global shared variable hDataset   as handle    no-undo.      /* ugly hack :( +++ */
       44   
       45   define variable serverType as character no-undo.
       46   
       47   define variable dcXID    as integer   no-undo.
       48   define variable result   as character no-undo.
       49   
       50   define variable monDir   as character no-undo initial "dc".
       51   
       52   define variable fifo_in  as character no-undo.
       53   define variable fifo_out as character no-undo.
       54   
       55   define variable qName    as character no-undo.
       56   
       57   define variable sendType as character no-undo initial "JSON".
       58   
       59   define variable sendPretty  as logical   no-undo initial false.
       60   define variable sendSchema  as logical   no-undo initial false.                 /* false = no 4GL specific stuff like FORMAT    */
       61   define variable omitInitVal as logical   no-undo initial false.
       62   
       63   define variable ok        as logical     no-undo.
       64   define variable i         as integer     no-undo.
       65   define variable trxNum    as integer     no-undo.
       66   define variable cmd       as character   no-undo.
       67   define variable UID       as character   no-undo.
       68   define variable dcList    as character   no-undo.
       69   define variable oldNow    as integer     no-undo.
       70   
       71   define new global shared variable dbgMode  as integer no-undo initial 1.
       72   define new global shared variable rawMode  as integer no-undo initial 5.
       73   define new global shared variable timeMode as integer no-undo initial 2.
       74   define new global shared variable rowLimit as integer no-undo.
       75   
       76   define new global shared variable custId       as character no-undo.
       77   define new global shared variable pt_shortname as character no-undo.
       78   define new global shared variable zmonName     as character no-undo.
       79   
       80   define new global shared variable x as integer no-undo initial 5.
       81   
       82   define stream inStrm.
       83   
       84   *** Encrypted Source ***
       85   *** Encrypted Source ***
       86   *** Encrypted Source ***
       87   *** Encrypted Source ***
       88   *** Encrypted Source ***
       89   *** Encrypted Source ***
       90   *** Encrypted Source ***
       91   *** Encrypted Source ***
       92   *** Encrypted Source ***
       93   *** Encrypted Source ***
       94   *** Encrypted Source ***
       95   *** Encrypted Source ***
       96   *** Encrypted Source ***
       97   *** Encrypted Source ***
       98   *** Encrypted Source ***
       99   *** Encrypted Source ***
      100   *** Encrypted Source ***
      101   *** Encrypted Source ***
      102   *** Encrypted Source ***
      103   *** Encrypted Source ***
      104   *** Encrypted Source ***
      105   *** Encrypted Source ***
      106   *** Encrypted Source ***
      107   *** Encrypted Source ***
      108   *** Encrypted Source ***
      109   *** Encrypted Source ***
      110   *** Encrypted Source ***
      111   *** Encrypted Source ***
      112   *** Encrypted Source ***
      113   *** Encrypted Source ***
      114   *** Encrypted Source ***
      115   *** Encrypted Source ***
      116   *** Encrypted Source ***
      117   *** Encrypted Source ***
      118   *** Encrypted Source ***
      119   *** Encrypted Source ***
      120   *** Encrypted Source ***
      121   *** Encrypted Source ***
      122   *** Encrypted Source ***
      123   *** Encrypted Source ***
      124   *** Encrypted Source ***
      125   *** Encrypted Source ***
      126   *** Encrypted Source ***
      127   *** Encrypted Source ***
      128   *** Encrypted Source ***
      129   *** Encrypted Source ***
      130   *** Encrypted Source ***
      131   *** Encrypted Source ***
      132   *** Encrypted Source ***
      133   *** Encrypted Source ***
      134   *** Encrypted Source ***
      135   *** Encrypted Source ***
      136   *** Encrypted Source ***
      137   *** Encrypted Source ***
      138   *** Encrypted Source ***
      139   *** Encrypted Source ***
      140   *** Encrypted Source ***
      141   *** Encrypted Source ***
      142   *** Encrypted Source ***
      143   *** Encrypted Source ***
      144   *** Encrypted Source ***
      145   *** Encrypted Source ***
      146   *** Encrypted Source ***
      147   *** Encrypted Source ***
      148   *** Encrypted Source ***
      149   *** Encrypted Source ***
      150   *** Encrypted Source ***
      151   *** Encrypted Source ***
      152   *** Encrypted Source ***
      153   *** Encrypted Source ***
      154    
      155   
      156   define temp-table tt_client no-undo
      157     field clientId    as character
      158     field lastContact as datetime-tz
      159     field sType       as character initial "JSON"                       /* XML or JSON                                          */
      160     field rMode       as integer   initial 5
      161     field tMode       as integer   initial 2
      162     field rLimit      as integer
      163   .
      164   
      165   define temp-table tt_dataCollector no-undo
      166     field xId      as integer
      167     field clientId as character
      168     field xActive  as logical
      169     field dcName   as character
      170     field dcHandle as handle
      171   .
      172   
      173   run ssg/sausage04.p persistent.                                         /* sausage lib                                          */
      174   
      175   function dcLaunch returns logical ( dcClient as character, dcProg as character, dcEnable as logical ):
      176   
      177     dcXID = dcXID + 1.
      178   
      179     create tt_dataCollector.
      180     assign
      181       tt_dataCollector.xId      = dcXID
      182       tt_dataCollector.clientId = dcClient
      183       tt_dataCollector.xActive  = dcEnable 
      184     .
      185   
      186     if not connected( "dictdb" ) then
      187       do:
      188         if lookup( substring( dcProg, length( monDir ) + 2 ), "apsv.p,dbid.p,df.p,netstat.p,osinfo.p,pasoe.p,appmon.p" ) <= 0 then
      189           do:
      190             if dbgMode >= 0 then message now dcProg "requires a db connection to launch".
      191             return yes.
      192           end.
      193       end.
      194   
      195     if dbgMode >= 4 then message now "launching data collector:" dcProg.
      196   
      197     run value( dcProg ) persistent set tt_dataCollector.dcHandle ( output tt_dataCollector.dcName ).
      198   
      199     if valid-handle( dcHandle ) then run "mon-init" in dcHandle.
      200   
      201     if dbgMode >= 0 then message now dcProg "has been initialized as" tt_dataCollector.dcName.
      202   
      203     return yes.
      204   
      205   end.
      206   
      207   function clientLaunch returns logical ( clientId as character ):
      208   
      209     define variable pname as character no-undo.
      210     define variable dname as character no-undo.
      211   
      212     find tt_client no-lock where tt_client.clientId = clientId no-error.
      213     if available( tt_client ) then
      214       do:
      215         message "Client:" clientId "exists!".
      216         return false.
      217       end.
      218      else
      219       do:
      220   
      221         /* message "Launching client:" clientId "!".
      222          */
      223   
      224         create tt_client.
      225         assign
      226           tt_client.clientId = clientId
      227   &IF DEFINED( OE10 ) &THEN
      228           tt_client.lastContact = now
      229   &ELSE
      230           tt_client.lastContact = time
      231   &ENDIF
      232         .
      233   
      234         if dbgMode >= 0 then message now "Launching data collectors" clientId.
      235   
      236         input stream inStrm from os-dir( monDir ).
      237   
      238         repeat:
      239           import stream inStrm ^ pname.
      240           pname = substring( pname, r-index( pname, monDir )).    /* run as a relative path */
      241   
      242           if substring( pname, length( pname) - 1, 2 ) = ".p" then dcLaunch( clientId, pname, yes ).
      243   
      244         end.
      245   
      246         input stream inStrm close.
      247   
      248   /*      /* load monitoring modules from an OS specific directory (if any)
      249    *       *
      250    *       */
      251    *    
      252    *      dname = "".
      253    * 
      254    *      if opsys begins "WIN" then
      255    *        dname = "WIN32".
      256    *       else if opsys = "unix" then
      257    *        do:
      258    *          input stream inStrm through value( "uname -a" ).
      259    *          import stream inStrm dname.
      260    *          input stream inStrm close.
      261    *        end.
      262    *  
      263    *      dname = monDir + "/os/" + dname.
      264    *
      265    *      file-info:file-name = dname.
      266    *
      267    *      if file-info:full-pathname <> ? and dname <> "" and dname <> ? then
      268    *        do:
      269    *
      270    *          input stream inStrm from os-dir( dname ).
      271    *
      272    *          repeat:
      273    *            import stream inStrm ^ pname.
      274    *            pname = substring( pname, index( pname, dname )). /* run as a relative path */
      275    *            if substring( pname, length( pname) - 1, 2 ) = ".p" then
      276    *              dcLaunch( clientId, pname, yes ).
      277    *          end.
      278    * 
      279    *          input stream inStrm close.
      280    * 
      281    *        end.
      282    */
      283   
      284         message now "all data collectors have been initialized".
      285   
      286         return true.
      287   
      288       end.
      289   
      290   end.
      291   
      292   
      293   procedure initProTopServer:
      294   
      295     define input parameter srvType as character no-undo.                          /* "direct", "http" or "stomp"                  */
      296     define input parameter p1      as character no-undo.                          /* server name                                  */
      297     define input parameter p2      as character no-undo.                          /* db name                                      */
      298   
      299     serverType = srvType.
      300   
      301     file-info:file-name = monDir.
      302     if ( file-info:full-pathname <> ? ) and index( file-info:file-type, "d" ) > 0 then
      303       . /* message "Monitor data collectors:" monDir. */
      304      else
      305       do:
      306         message "Cannot find directory:" monDir.
      307         quit.
      308       end.
      309   
      310     if serverType <> "direct" then                                                /* initialize protop environment                */
      311       do:
      312         run lib/protoplib.p persistent.
      313         run lib/vstlib.p persistent.
      314         run lib/protop-cfg.p persistent.
      315       end.
      316   
      317   &IF DEFINED( OE10 ) &THEN
      318     create dataset hDataset.
      319   &ELSE
      320     empty temp-table tt_dataset.
      321   &ENDIF
      322   
      323     return.
      324   
      325   end.
      326   
      327   
      328   procedure doRequest:
      329   
      330     define input  parameter cmd    as character no-undo.
      331     define output parameter result as longchar  no-undo.
      332   
      333     define variable dcName  as character no-undo.
      334     define variable xList   as character no-undo.
      335     define variable argVal  as character no-undo.
      336     define variable argList as character no-undo.
      337   
      338     define variable cscCmd  as character no-undo.
      339     define variable dbaCmd  as character no-undo.
      340   
      341     define variable my_dbAccess as int64 no-undo.
      342     define variable my_dbRead   as int64 no-undo.
      343   
      344     define variable winPID as integer no-undo.
      345   
      346     define variable i as integer no-undo.
      347   
      348     assign
      349       UID     = ""
      350       dcList  = ""
      351       xList   = ""
      352       argList = ""
      353     .
      354   
      355   /* +++db
      356    *  find first _myconnection no-lock.
      357    *  find _userio no-lock where _userio-id = _myconn-userid + 1.
      358    *  assign
      359    *    my_dbAccess = _userio-dbAccess
      360    *    my_dbRead   = _userio-dbRead
      361    *  .
      362    */
      363   
      364   &IF DEFINED( OE10 ) &THEN
      365     assign
      366       ok = hDataset:set-buffers( "" )
      367     no-error.
      368   &ELSE
      369     empty temp-table tt_dataset.
      370   &ENDIF
      371   
      372     if num-entries( cmd, "|" ) = 1 then
      373       xList = cmd.
      374      else
      375       assign
      376         UID    = entry( 1, cmd, "|" )
      377         xList  = entry( 2, cmd, "|" )
      378       .
      379   
      380     if xList begins "xcmd=" then
      381       do:
      382   
      383         find tt_client no-lock where tt_client.clientId = UID.
      384         assign
      385           sendType = tt_client.sType
      386           rawMode  = tt_client.rMode
      387           timeMode = tt_client.tMode
      388           rowLimit = tt_client.rLimit
      389         .
      390   
      391         if num-entries( entry( 2, xList, "=" ), "+" ) > 1 then
      392           argList = entry( 2, entry( 2, xList, "=" ), "+" ).
      393   
      394         if opsys = "unix" then
      395           do:
      396             cscCmd = "$DLC/bin/promon  &1 < $PROTOP/etc/promon.csc_&2 > /dev/null 2>&&1".
      397             dbaCmd = "$DLC/bin/_proutil &1 -C dbanalys -Bp 10 > $PROTOP/dbanalys/&2.dba 2>&&1 &&".
      398           end.
      399          else
      400           do:
      401             cscCmd = "%DLC%~\bin~\promon  &1 < %PROTOP%~\etc~\promon.csc_&2 > nul 2>&&1".
      402             dbaCmd = "%DLC%~\bin~\_proutil &1 -C dbanalys -Bp 10 > %PROTOP%~\dbanalys~\&2.dba 2>&&1 &&".
      403          /* dbaCmd = "%DLC%~\bin~\_proutil &1 -C dbanalys -Bp 10 > %PROTOP%~\dbanalys~\&2.dba 2>&&1".    */
      404          /* dbaCmd = "%PROTOP%~\bin~\dbanalys.bat &1 %PROTOP%~\dbanalys~\&2.dba". */
      405          /* dbaCmd = "start /b %DLC%~\bin~\_proutil &1 -C dbanalys -Bp 10 > %PROTOP%~\dbanalys~\&2.dba 2>&&1". */
      406          /* dbaCmd = "start /b %PROTOP%~\bin~\dbanalys.bat &1 %PROTOP%~\dbanalys~\&2.dba". */
      407          /* dbaCmd = "%PROTOP%~\bin~\dbanalys.bat &1 %PROTOP%~\dbanalys~\&2.dba". */
      408           end.
      409   
      410         case entry( 1, entry( 2, xList, "=" ), "+" ):
      411   
      412           /* these impact all client sessions
      413            */
      414   
      415           when "csc_on"   then os-command silent value( substitute( cscCmd, pdbname( 1 ), "on"  )).
      416           when "csc_off"  then os-command silent value( substitute( cscCmd, pdbname( 1 ), "off" )).
      417   
      418           when "dba"      then
      419             do:
      420               if opsys = "unix" then
      421                 os-command silent value( substitute( dbaCmd, pdbname( 1 ), pt_shortname )).
      422                else
      423                 os-command silent value( substitute( dbaCmd, pdbname( 1 ), pt_shortname )).
      424                 /* os-command no-wait value( substitute( dbaCmd, pdbname( 1 ), pt_shortname )). */
      425                 /* run spawn ( substitute( dbaCmd, pdbname( 1 ), pt_shortname ), "", output winPID ). */
      426   
      427             end.
      428   
      429           /* these are specific to a client session
      430            */
      431   
      432           when "raw_Interval"   then rawMode = 5.
      433           when "raw_Cumulative" then rawMode = 4.
      434           when "raw_Raw"        then rawMode = 3.
      435   
      436           when "time_Summary"   then timeMode = 1.
      437           when "time_Rate"      then timeMode = 2.
      438   
      439           when "rowLimit" then rowLimit = integer( entry( 2, entry( 2, xList, "=" ), "+" )).
      440           when "sendType" then
      441             do:
      442               if lookup( argList, "XML,JSON" ) > 0 then
      443                 sendType = argList.
      444             end.
      445   
      446         end.
      447   
      448         assign
      449           tt_client.sType  = sendType
      450           tt_client.rMode  = rawMode
      451           tt_client.tMode  = timeMode
      452           tt_client.rLimit = rowLimit
      453         .
      454   
      455         result = "".
      456   
      457         return.
      458   
      459       end.
      460      else
      461       do:
      462   
      463         /* get a dcList that is only dcNames -- pull any args (specified by ":") out of the command string
      464          */
      465   
      466         do i = 1 to num-entries( xList ):
      467   
      468           assign
      469             dcName = entry( i, xList )
      470             argVal = ""
      471           .
      472   
      473           if num-entries( dcName, ":" ) > 1 then
      474             assign
      475               argVal  = entry( 2, dcName, ":" )
      476               dcName  = entry( 1, dcName, ":" )
      477             .
      478   
      479           assign
      480             argList = argList + ( if dcList > "" then ":" else "" ) + argVal              /* dcList is deliberate...              */
      481             dcList  = dcList +  ( if dcList > "" then "," else "" ) + dcName
      482           .
      483   
      484         end.
      485   
      486         find first tt_dataCollector where tt_dataCollector.clientId = UID no-error.
      487         if not available( tt_dataCollector ) then clientLaunch( UID ).
      488   
      489         for each tt_dataCollector where tt_dataCollector.clientId = UID:
      490           tt_dataCollector.xActive = ( dcList = "" or dcList = ? or dcList = "all" ).
      491         end.
      492   
      493         if num-entries( dcList ) >= 1 and dcList <> "all" then
      494           for each tt_dataCollector where tt_dataCollector.clientId = UID:
      495             tt_dataCollector.xActive = ( lookup( tt_dataCollector.dcName, dcList ) > 0 ).
      496           end.
      497   
      498         for each tt_dataCollector no-lock where tt_dataCollector.clientId = UID and tt_dataCollector.xActive = true:
      499   
      500           /* oldNow = mtime. */
      501           if num-entries( dcList ) > 0 then
      502             do:
      503               argVal = entry( lookup( tt_dataCollector.dcName, dcList ), argList, ":" ).
      504               if valid-handle( dcHandle ) then run "mon-update" in dcHandle ( argVal ).
      505             end.
      506   
      507         /*  message tt_dataCollector.dcName ( mtime - oldNow ). */
      508   
      509         end.
      510   
      511       end.
      512   
      513     /* oldNow = mtime. */
      514   
      515   /* +++db
      516     find _userio no-lock where _userio-id = _myconn-userid + 1.
      517     assign
      518       my_dbAccess = _userio-dbAccess - my_dbAccess
      519       my_dbRead   = _userio-dbRead   - my_dbRead
      520     .
      521    */
      522   
      523     publish "updPTStats" ( my_dbAccess, my_dbRead ).
      524   
      525           526   *** Encrypted Source ***
      527   *** Encrypted Source ***
      528   *** Encrypted Source ***
      529   *** Encrypted Source ***
      530   *** Encrypted Source ***
      531   *** Encrypted Source ***
      532   *** Encrypted Source ***
      533   *** Encrypted Source ***
      534   *** Encrypted Source ***
      535   *** Encrypted Source ***
      536   *** Encrypted Source ***
      537   *** Encrypted Source ***
      538   *** Encrypted Source ***
      539   *** Encrypted Source ***
      540   *** Encrypted Source ***
      541   *** Encrypted Source ***
      542   *** Encrypted Source ***
      543   *** Encrypted Source ***
      544   *** Encrypted Source ***
      545   *** Encrypted Source ***
      546   *** Encrypted Source ***
      547   *** Encrypted Source ***
      548   *** Encrypted Source ***
      549   *** Encrypted Source ***
      550   *** Encrypted Source ***
      551   *** Encrypted Source ***
      552   *** Encrypted Source ***
      553   *** Encrypted Source ***
      554   *** Encrypted Source ***
      555   *** Encrypted Source ***
      556   *** Encrypted Source ***
      557   *** Encrypted Source ***
      558   *** Encrypted Source ***
      559   *** Encrypted Source ***
      560   *** Encrypted Source ***
      561   *** Encrypted Source ***
      562   *** Encrypted Source ***
      563   *** Encrypted Source ***
      564   *** Encrypted Source ***
      565   *** Encrypted Source ***
      566   *** Encrypted Source ***
      567   *** Encrypted Source ***
      568   *** Encrypted Source ***
      569   *** Encrypted Source ***
      570   *** Encrypted Source ***
      571   *** Encrypted Source ***
      572   *** Encrypted Source ***
      573   *** Encrypted Source ***
      574   *** Encrypted Source ***
      575   *** Encrypted Source ***
      576   *** Encrypted Source ***
      577   *** Encrypted Source ***
      578   *** Encrypted Source ***
      579   *** Encrypted Source ***
      580   *** Encrypted Source ***
      581   *** Encrypted Source ***
      582   *** Encrypted Source ***
      583   *** Encrypted Source ***
      584   *** Encrypted Source ***
      585   *** Encrypted Source ***
      586   *** Encrypted Source ***
      587   *** Encrypted Source ***
      588   *** Encrypted Source ***
      589   *** Encrypted Source ***
      590   *** Encrypted Source ***
      591   *** Encrypted Source ***
      592   *** Encrypted Source ***
      593   *** Encrypted Source ***
      594   *** Encrypted Source ***
      595   *** Encrypted Source ***
      596   *** Encrypted Source ***
      597   *** Encrypted Source ***
      598   *** Encrypted Source ***
      599   *** Encrypted Source ***
      600   *** Encrypted Source ***
      601   *** Encrypted Source ***
      602   *** Encrypted Source ***
      603   *** Encrypted Source ***
      604   *** Encrypted Source ***
      605   *** Encrypted Source ***
      606   *** Encrypted Source ***
      607   *** Encrypted Source ***
      608   *** Encrypted Source ***
      609   *** Encrypted Source ***
      610   *** Encrypted Source ***
      611    
      612   
      613     return.
      614   
      615   end.
      616   
      617   
      618   procedure getRequest:
      619   
      620     define output parameter cmd as character no-undo.
      621   
      622   &IF DEFINED( OE10 ) &THEN
      623     assign
      624       ok = hDataset:set-buffers( "" )
      625     no-error.
      626   &ELSE
      627     empty temp-table tt_dataset.
      628   &ENDIF
      629   
      630     cmd = "".
      631   
      632     get_req: do while true
      633       on error  undo, retry get_req
      634       on endkey undo, retry get_req:
      635   
      636       if not retry then
      637         i = 0.
      638        else       /* maybe we should accumulate incomplete cmd strings? */
      639         do:
      640           i = i + 1.
      641           message now i "retrying get_req: interrupted cmd read".
      642           if cmd > "" then
      643             do:
      644               message now i "cmd interrupted:" cmd.
      645               leave get_req.
      646             end.
      647           if i >= 5 then leave get_req.
      648         end.
      649   
      650       /***
      651       if serverType = "http" then
      652         do:
      653           input stream inStrm from value( fifo_in ) no-echo.
      654           import stream inStrm unformatted cmd.
      655           input stream inStrm close.
      656         end.
      657        else if serverType = "stomp" then
      658         do:
      659           message {&NOW} "waiting on q" qName "for stomp message".
      660           wait-for "U1" of this-procedure.
      661           message {&NOW} "stomp message received".
      662           cmd = string( result ).                         /* "result" is populated by newStompMessage()   */
      663         end.
      664        ***/
      665   
      666       leave get_req.
      667   
      668     end. /* get_req */
      669   
      670     return.
      671   
      672   end.
      673   
      674   
      675   function add2ds returns logical ( input h as handle ):
      676   
      677   &IF DEFINED( OE10 ) &THEN
      678     hDataset:add-buffer( h ).
      679   &ELSE
      680     create tt_dataset.
      681     ttHandle = h.
      682   &ENDIF
      683   
      684     return true.
      685   
      686   end.
      687   
      688   
      689   function getTempTableHandle returns handle ( input n as character ):
      690   
      691   &IF DEFINED( OE10 ) &THEN
      692     define variable i as integer no-undo.
      693     define variable b as handle  no-undo.
      694     
      695     do i = 1 to hDataset:num-buffers:
      696       b = hDataset:get-buffer-handle( i ).
      697       if b:name = n then return b.
      698     end.
      699   &ELSE
      700     for each tt_dataset:
      701       if ttHandle:name = n then return ttHandle.   
      702     end.
      703   &ENDIF
      704   
      705     return ?.
      706   
      707   end.
      708   
      709   
      710   /*** main body
      711    ***
      712    ***/
      713   
      714   /* plain old protop users might not have a custid and that's ok
      715    *
      716    */
      717   
      718   file-info:file-name = "etc/custid.cfg".
      719   if file-info:full-pathname = ? then
      720     custId = "".
      721    else
      722     do on error undo, leave
      723        on endkey undo, leave:
      724       input stream inStrm from value( file-info:full-pathname ).
      725       import stream inStrm unformatted custId.
      726       input stream inStrm close.
      727     end.
      728   
      729   if os-getenv( "SENDTYPE" ) <> ? and lookup( os-getenv( "SENDTYPE" ), "JSON,XML" ) > 0 then sendType = os-getenv( "SENDTYPE" ).
      730   
      731   session:add-super-procedure( this-procedure ).
      732   
      733   return.
