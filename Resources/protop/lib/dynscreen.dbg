        1   /* lib/dynscreen.p
        2    *
        3    */
        4   
        5   
        6   /* lib/dynscreen.i
        7    *
        8    */
        9   
       10   /*
       11   function dynViewerInit  returns logical ( f as handle, dcName as character, ttName as character, evtName as character, dispOrder as integer ) in super.
       12   function dynBrowserInit returns logical ( f as handle, dcName as character, ttName as character, evtName as character, dispOrder as integer ) in super.
       13    */
       14   
       15   function dynScreenUpdate returns logical ( data as longchar ) in super.
       16   function rowDisplay returns logical ( z as handle ) in super.
       17   
       18   function getBrowseColumnByName returns handle ( b as handle, n as character ) in super.
       19   
       20    
       21   
       22   /*******************************************************************************
       23    *******************************************************************************
       24    **                                                                           **
       25    **                                                                           **
       26    **  Copyright 2003-2006 Tom Bascom, Greenfield Technologies                  **
       27    **  http://www.greenfieldtech.com                                            **
       28    **                                                                           **
       29    **  ProTop is free software; you can redistribute it and/or modify it        **
       30    **  under the terms of the GNU General Public License (GPL) as published     **
       31    **  by the Free Software Foundation; either version 2 of the License, or     **
       32    **  at your option) any later version.                                       **
       33    **                                                                           **
       34    **  ProTop is distributed in the hope that it will be useful, but WITHOUT    **
       35    **  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or    **
       36    **  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License     **
       37    **  for more details.                                                        **
       38    **                                                                           **
       39    **  See TERMS.TXT for more information regarding the Terms and Conditions    **
       40    **  of use and alternative licensing options for this software.              **
       41    **                                                                           **
       42    **  A copy of the GPL is in GPL.TXT which was provided with this package.    **
       43    **                                                                           **
       44    **  See http://www.fsf.org for more information about the GPL.               **
       45    **                                                                           **
       46    **                                                                           **
       47    *******************************************************************************
       48    *******************************************************************************
       49    *
       50    * protop.i
       51    *
       52    * Header file for protop family of programs
       53    *
       54    *
       55    * Known Bugs & Issues:
       56    *
       57    *
       58    * To Do:
       59    *
       60    *
       61    * Author:
       62    *
       63    *      Tom Bascom, Greenfield Technologies
       64    *      http://www.greenfieldtech.com
       65    *      August 28, 2003
       66    *
       67    */
       68   
       69   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 11.4 &THEN
       70   &global-define  FASTLOCK        true
       71   &ELSE
       72   &global-define  FASTLOCK        false
       73   &ENDIF
       74   
       75   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 11.0 &THEN
       76   &global-define  OE11            "yes"
       77   &global-define  xDEBUGTT        false
       78   &ENDIF
       79   
       80   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.2 AND PROVERSION >= "10.2B" &THEN
       81   &global-define  NOSERIALIZE     serialize-hidden
       82   &ENDIF
       83   
       84   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.1 AND PROVERSION >= "10.1B" &THEN
       85   &global-define  BIGINT          int64
       86   &ELSE
       87   &global-define  BIGINT          decimal
       88   &ENDIF
       89   
       90   
       91   /* lib/v9.i
       92    *
       93    */
       94   
       95   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) < 10.0 &THEN
       96   &global-define  CPYLOB  "no"
       97   &global-define  NOW     substitute( "&1 &2", today, string( time, "hh:mm:ss" ))
       98   &global-define  LNGCR   character
       99   &global-define  DTZ     integer
      100   &global-define  BIGINT  decimal
      101   &ELSE
      102   &global-define  OE10    "yes"
      103   &global-define  NOW     now
      104   &global-define  LNGCR   longchar
      105   &global-define  DTZ     datetime-tz
      106   &global-define  BIGINT  int64
      107   &ENDIF
      108    
      109   
      110   /* use extended _connect fields: -client, -cache*
      111    */
      112   
      113   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.1 AND PROVERSION >= "10.1C" &THEN
      114   &global-define  CONNECTX        "yes"
      115   &ELSE
      116   &global-define  CONNECTX        "no"
      117   &ENDIF
      118   
      119   define stream inStrm.
      120   
      121   define new global shared variable dbgMode as integer no-undo initial 1.
      122   
      123   /* The values for these are defined in etc/protop.cfg and set by lib/protop-cfg.p
      124    *
      125    * someday everyone will have OO and I will replace these with a gsv class
      126    * or something of that ilk
      127    *
      128    */
      129   
      130   define new global shared variable pt_shortname   as character no-undo.
      131   define new global shared variable pt_uniqName    as character no-undo.
      132   define new global shared variable pt_server      as character no-undo.
      133   define new global shared variable pt_resrcType   as character no-undo.
      134   
      135   define new global shared variable pt_tmpdir      as character no-undo initial "/tmp".
      136   define new global shared variable pt_logdir      as character no-undo initial "/tmp".
      137   define new global shared variable pt_rptdir      as character no-undo initial "/tmp".
      138   define new global shared variable pt_logname     as character no-undo initial "&5.&2.&3".
      139   define new global shared variable pt_mailcmd     as character no-undo initial 'mailx "-s &1" '.
      140   
      141   define new global shared variable pt_votrx       as integer   no-undo initial 1800.
      142   define new global shared variable pt_lktbllim    as integer   no-undo initial 0.
      143   define new global shared variable pt_bkupstale   as integer   no-undo initial 26.
      144   define new global shared variable pt_bogomips    as integer   no-undo initial 1000000.
      145   define new global shared variable pt_ioresp      as integer   no-undo initial 100.
      146   define new global shared variable pt_ioFileName  as character no-undo.
      147   define new global shared variable pt_dfCmd       as character no-undo.
      148   
      149   define new global shared variable pt_AICheckInterval   as integer no-undo initial 60.
      150   define new global shared variable pt_PICACheckInterval as integer no-undo initial 60.
      151   define new global shared variable pt_appsrvStuck       as integer no-undo initial 120.
      152   
      153   define new global shared variable pt_bibkupAlert as integer   no-undo.          /* alert on long bi backup phase                */
      154   define new global shared variable pt_bibkupAlarm as integer   no-undo.          /* alarm on long bi backup phase                */
      155   define new global shared variable pt_bibkupPage  as integer   no-undo.          /* page  on long bi backup phase                */
      156   
      157   define new global shared variable pt_bkupAlert   as integer   no-undo.          /* alert on long db backup                      */
      158   define new global shared variable pt_bkupAlarm   as integer   no-undo.          /* alarm on long db backup                      */
      159   define new global shared variable pt_bkupPage    as integer   no-undo.          /* page  on long db backup                      */
      160   
      161   define new global shared variable pt_userLock    as logical   no-undo.          /* enable _userLock  data?                      */
      162   define new global shared variable pt_doZippy     as logical   no-undo.          /* enable "user experience" (aka "zippy")?      */
      163   define new global shared variable pt_useRFUtil   as logical   no-undo.          /* use rfutil to gather after-imaging status?   */
      164   
      165   define new global shared variable pt_updAreaData as integer   no-undo.          /* how often should we report storage area xref details from dbanalys? */
      166   
      167   define new global shared variable pt_zoomTo      as integer no-undo.            /* new zoomed monInt                            */
      168   
      169   define new global shared variable ptDBName     as character no-undo.                    /* the db logical name          */
      170   define new global shared variable rowLimit     as integer   no-undo initial 100.        /* 50?                          */
      171   
      172   /* do-sumSample() manipulates these -- ugly, ugly, ugly... (obsolete?)
      173    * 
      174    */
      175   
      176   define new global shared variable stime as integer no-undo.                     /* start time                           */
      177   define new global shared variable ltime as integer no-undo.                     /* last time                            */
      178   define new global shared variable xtime as integer no-undo.                     /* total time                           */
      179   define new global shared variable itime as integer no-undo.                     /* iteration time                       */
      180   
      181   define new global shared variable chkp-base   as integer no-undo initial ?.     /* cover for the lack of a VST field    */
      182   
      183                                                                                   /* corresponding to base checkpoint#    */
      184   /** Global Shared Temp Table Definitions
      185    **
      186    ** Yup, they're shared.  But this stuff makes no sense across session boundaries anyway.
      187    ** And a shared temp-table is logically the same as a db table so who really cares?
      188    **
      189    **/
      190   
      191   /* cache _File and _Index records so that we don't keep hitting the db to translate
      192    */
      193   
      194   define new global shared temp-table tt_tbl no-undo
      195     field xid      as integer                                             /* _File._File-Num              */
      196     field tstatid  as integer                                             /* _TableStat._TableStat-Id     */
      197     field areaNum  as integer                                             /* _Storage-Object._Area-Number */
      198     field tblPool  as character                                           /* get-bits( _object-attrib, 7, 1 ) = 1 */
      199     field tblname  as character                                           /* _File._File-Name             */
      200     index xid-idx is unique primary xid.
      201   
      202   define new global shared temp-table tt_idx no-undo
      203     field xid      as integer                                             /* _Index._Idx-Num              */
      204     field istatid  as integer                                             /* _IndexStat._IndexStat-Id     */
      205     field idxname  as character                                           /* _Index._Idx-Name             */
      206     field idxnote  as character
      207     field idxRoot  as int64                                           /* _Storage-Object._Object-Root */
      208     field tblnum   as integer                                             /* _File._File-Num              */
      209     field areaNum  as integer                                             /* _Storage-Object._Area-Number */
      210     field idxPool  as character                                           /* get-bits( _object-attrib, 7, 1 ) = 1 */
      211     field tblname  as character                                           /* _File._File-Name             */
      212     index xid-idx is unique primary xid.
      213   
      214   define new global shared temp-table tt_areaExtent no-undo
      215     field areaNum  as integer                                             /* _areaExtent._Area-Number     */
      216     field extNum   as integer                                             /* _areaExtent._Extent-Number   */
      217   
      218     field extSize  as decimal                                             /* _areaExtent._Extent-Size     */
      219     field extType  as integer                                             /* _areaExtent._Extent-Type     */
      220     field extPath  as character                                           /* _areaExtent._Extent-Path     */
      221   
      222     index ae-idx is unique primary areaNum extNum.
      223   
      224   define new global shared temp-table tt_area no-undo
      225     field xid      as integer    format ">>>9"
      226     field SANum    as integer    format ">>>9"        label "#"
      227     field areaPool as character  format "x(2)"        label "BX"
      228   /*field areaStatus-Id as {&BIGINT} format ">>>9"    label "Id" */
      229     field SAName   as character  format "x(30)"       label "Area Name"
      230     field allocGB  as decimal    format ">>>>>9.99"   label "Allocated"
      231     field varGB    as decimal    format ">>>>>9.99"   label "Variable"
      232     field totGB    as decimal    format ">>>>>>9.99"  label "Tot GB"
      233     field hiGB     as decimal    format ">>>>>9.99"   label "Hi Water" serialize-hidden
      234     field freeGB   as decimal    format ">>>>>9.99"   label "Free GB"
      235     field pctAlloc as decimal    format ">>>>>9%"     label "%Alloc"
      236     field pctLastX as decimal    format ">>>>9%"      label "%LastX"
      237   
      238     field blkszkb as integer     format ">>9"         label "BSZ"
      239     field rpb     as integer     format ">>9"         label "RPB"
      240     field clstrsz as integer     format ">>9"         label "CSZ"
      241   
      242     field numTbls as integer     format ">>>>9"       label "#Tbls"
      243     field numIdxs as integer     format ">>>>9"       label "#Idxs"
      244     field numLOBs as integer     format ">>>>9"       label "#LOBs"
      245   
      246     field numExts as integer     format ">>>>9"       label "#Exts"
      247     field hasVar  as logical     format "Yes/No"      label "Var?"
      248   
      249     field xnote   as character   format "x"           label "*"
      250   
      251     field areaMaxPct as decimal  format ">>9.999%"    label "Max%"
      252     field idx3264    as decimal  format ">>9.999%"    label "Bug%"
      253   
      254     index pctAlloc-idx is primary pctAlloc descending
      255     index pctLastX-idx pctLastX pctAlloc descending
      256     index allocGB-idx allocGB descending
      257     index totGB-idx totGB descending
      258     index xid-idx is unique xid
      259     index SANum-idx is unique SANum
      260     index SAName-idx is unique SAName
      261   .
      262   
      263   *** Encrypted Source ***
      264   *** Encrypted Source ***
      265   *** Encrypted Source ***
      266   *** Encrypted Source ***
      267   *** Encrypted Source ***
      268   *** Encrypted Source ***
      269   *** Encrypted Source ***
      270   *** Encrypted Source ***
      271   *** Encrypted Source ***
      272   *** Encrypted Source ***
      273   *** Encrypted Source ***
      274   *** Encrypted Source ***
      275   *** Encrypted Source ***
      276   *** Encrypted Source ***
      277   *** Encrypted Source ***
      278   *** Encrypted Source ***
      279   *** Encrypted Source ***
      280   *** Encrypted Source ***
      281   *** Encrypted Source ***
      282   *** Encrypted Source ***
      283   *** Encrypted Source ***
      284   *** Encrypted Source ***
      285   *** Encrypted Source ***
      286   *** Encrypted Source ***
      287   *** Encrypted Source ***
      288   *** Encrypted Source ***
      289   *** Encrypted Source ***
      290   *** Encrypted Source ***
      291   *** Encrypted Source ***
      292   *** Encrypted Source ***
      293   *** Encrypted Source ***
      294   *** Encrypted Source ***
      295   *** Encrypted Source ***
      296   *** Encrypted Source ***
      297   *** Encrypted Source ***
      298   *** Encrypted Source ***
      299   *** Encrypted Source ***
      300   *** Encrypted Source ***
      301   *** Encrypted Source ***
      302   *** Encrypted Source ***
      303   *** Encrypted Source ***
      304   *** Encrypted Source ***
      305   *** Encrypted Source ***
      306   *** Encrypted Source ***
      307   *** Encrypted Source ***
      308   *** Encrypted Source ***
      309   *** Encrypted Source ***
      310   *** Encrypted Source ***
      311   *** Encrypted Source ***
      312   *** Encrypted Source ***
      313   *** Encrypted Source ***
      314   *** Encrypted Source ***
      315   *** Encrypted Source ***
      316   *** Encrypted Source ***
      317   *** Encrypted Source ***
      318   *** Encrypted Source ***
      319   *** Encrypted Source ***
      320   *** Encrypted Source ***
      321   *** Encrypted Source ***
      322   *** Encrypted Source ***
      323   *** Encrypted Source ***
      324   *** Encrypted Source ***
      325   *** Encrypted Source ***
      326   *** Encrypted Source ***
      327   *** Encrypted Source ***
      328   *** Encrypted Source ***
      329   *** Encrypted Source ***
      330   *** Encrypted Source ***
      331   *** Encrypted Source ***
      332   *** Encrypted Source ***
      333    
      334   
      335   /*******************************************************************************
      336    *******************************************************************************
      337    **                                                                           **
      338    **                                                                           **
      339    **  Copyright 2003-2006 Tom Bascom, Greenfield Technologies                  **
      340    **  http://www.greenfieldtech.com                                            **
      341    **                                                                           **
      342    **  ProTop is free software; you can redistribute it and/or modify it        **
      343    **  under the terms of the GNU General Public License (GPL) as published     **
      344    **  by the Free Software Foundation; either version 2 of the License, or     **
      345    **  at your option) any later version.                                       **
      346    **                                                                           **
      347    **  ProTop is distributed in the hope that it will be useful, but WITHOUT    **
      348    **  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or    **
      349    **  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License     **
      350    **  for more details.                                                        **
      351    **                                                                           **
      352    **  See TERMS.TXT for more information regarding the Terms and Conditions    **
      353    **  of use and alternative licensing options for this software.              **
      354    **                                                                           **
      355    **  A copy of the GPL is in GPL.TXT which was provided with this package.    **
      356    **                                                                           **
      357    **  See http://www.fsf.org for more information about the GPL.               **
      358    **                                                                           **
      359    **                                                                           **
      360    *******************************************************************************
      361    *******************************************************************************
      362    *
      363    * protoplib.i
      364    *
      365    * ProTop infrastructure library definitions
      366    *
      367    */
      368   
      369   function uDateTime returns integer () in super.
      370   function string2uDateTime returns integer( input p_text as character ) in super.
      371   function searchDir returns character ( input xDir as character ) in super.
      372   function unsignMe returns decimal ( input s as decimal, input i as integer ) in super.
      373   function hr returns decimal ( input lr as decimal, input osr as decimal, output hr-str as character, output hr as decimal, output mr as decimal ) in super.
      374   function do-SumSample returns logical ( output p_index as integer, output p_time  as integer ) in super.
      375   function myPID returns character () in super.
      376   function hilite returns logical ( input b as handle, input p_metric as character, input p_value as character, output p_attr as character ) in super.
      377   
      378   /* end protoplib.i */
      379    
      380   
      381   /*******************************************************************************
      382    *******************************************************************************
      383    **                                                                           **
      384    **                                                                           **
      385    **  Copyright 2003-2006 Tom Bascom, Greenfield Technologies                  **
      386    **  http://www.greenfieldtech.com                                            **
      387    **                                                                           **
      388    **  ProTop is free software; you can redistribute it and/or modify it        **
      389    **  under the terms of the GNU General Public License (GPL) as published     **
      390    **  by the Free Software Foundation; either version 2 of the License, or     **
      391    **  at your option) any later version.                                       **
      392    **                                                                           **
      393    **  ProTop is distributed in the hope that it will be useful, but WITHOUT    **
      394    **  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or    **
      395    **  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License     **
      396    **  for more details.                                                        **
      397    **                                                                           **
      398    **  See TERMS.TXT for more information regarding the Terms and Conditions    **
      399    **  of use and alternative licensing options for this software.              **
      400    **                                                                           **
      401    **  A copy of the GPL is in GPL.TXT which was provided with this package.    **
      402    **                                                                           **
      403    **  See http://www.fsf.org for more information about the GPL.               **
      404    **                                                                           **
      405    **                                                                           **
      406    *******************************************************************************
      407    *******************************************************************************
      408    *
      409    * vstlib.i
      410    *
      411    * VST library definitions
      412    *
      413    */
      414   
      415   function aiInfo returns character ( input vAiFile as character, output vAiGenNum as integer ) in super.
      416   function chkai returns integer ( output ai_exts as integer, output ai_full as integer, output ai_empty as integer ) in super.
      417   function chkarea returns integer ( input threshold as decimal, output worst as decimal ) in super.
      418   function chkptNum returns integer ( input-output oldbi as integer ) in super.
      419   
      420   function connectFlags returns character ( input cnxId as integer ) in super.
      421   function connectName returns character ( input cnxId as integer, input cnxFlags as character ) in super.
      422   function lastStatement returns character( input cnxId as integer, output lineNum as integer, output procName as character ) in super.
      423   
      424   function isAIEnabled returns logical () in super.
      425   function isReplSource returns logical () in super.
      426   function isReplTarget returns logical () in super.
      427   function isBackupRunning returns logical () in super.
      428   function isWorkgroup returns logical () in super.
      429   
      430   function getStartupX returns character ( input v as character, input p1 as character, input p2 as character ) in super.
      431   
      432   /* end vstlib.i */
      433    
      434   
      435   function add2ds returns logical ( input h as handle ) in super.
      436   function getTempTableHandle returns handle ( input n as character ) in super.
      437   
      438   /* end protop.i */
      439    
      440   
      441   define new global shared variable pt_first as logical no-undo.
      442   
      443   define new global shared variable hDataset   as handle    no-undo.      /* ugly hack :( +++ */
      444   
      445   
      446   /* lib/tt_screenlist.i
      447    */
      448   
      449   define new global shared temp-table tt_screenList no-undo
      450   
      451     field displayOrder  as integer
      452     field screenName    as character format "x(30)"
      453     field ttName        as character format "x(18)"
      454     field dcName        as character
      455     field evtName       as character
      456     field frameHandle   as handle
      457     field bufferHandle  as handle
      458     field queryHandle   as handle
      459     field browseHandle  as handle
      460     field screenType    as character
      461     field screenRow     as integer
      462     field minRows       as integer
      463     field maxRows       as integer
      464     field resultRows    as integer
      465     field screenVisible as logical
      466     field screenActive  as logical
      467     field sortBy        as character format "x(16)" label "Sort Column"
      468     field sortDir       as character format "x(4)"
      469     field sortFieldList as character format "x(74)"
      470   
      471     index ttName-idx is unique primary
      472       ttName
      473     index scrFrame is unique
      474       frameHandle
      475   .
      476    
      477   
      478   define temp-table tt_screenElement no-undo
      479     field frameName     as character
      480     field elementName   as character
      481     field elementRow    as integer
      482     field elementCol    as integer
      483     field elementType   as character
      484     field frameHandle   as handle
      485     field elementHandle as handle
      486     field elementValue  as character
      487     field proType       as character
      488     field proFormat     as character
      489     field elementAlign  as character
      490     index scrFrame is unique primary
      491       frameName
      492       elementName
      493     index elNm_frNm_elH-idx
      494       elementName
      495       frameHandle
      496       elementHandle
      497   .
      498   
      499   define new global shared temp-table tt_browseColumnList no-undo
      500     field browseName     as character
      501     field columnName     as character
      502     field browseHandle   as handle
      503     field bufferHandle   as handle
      504     field columnHandle   as handle
      505     field columnWidth    as integer
      506     index brwCol is unique primary
      507       browseName
      508       columnName
      509     index brwHdl
      510       browseHandle
      511   .
      512   
      513   define variable ok as logical no-undo.
      514   
      515   define variable alwaysGrab as character no-undo.
      516   
      517   alwaysGrab = "DBId".                                                                            /*   "DBId,Dashboard,Configuration"             */
      518   
      519   define variable clrmap  as character no-undo initial "normal,alert,warning".
      520   define variable clrterm as character no-undo.
      521   
      522   /* protermcap*
      523    *
      524    *      :COLOR 5 BLACK=\E[30m:\E[0m:\
      525    *      :COLOR 6 RED=\E[31m:\E[0m:\
      526    *      :COLOR 7 GREEN=\E[32m:\E[0m:\
      527    *      :COLOR 8 YELLOW=\E[33m:\E[0m:\
      528    *      :COLOR 9 BLUE=\E[34m:\E[0m:\
      529    *      :COLOR 10 MAGENTA=\E[35m:\E[0m:\
      530    *      :COLOR 11 CYAN=\E[36m:\E[0m:\
      531    *      :COLOR 12 WHITE=\E[5;37m:\E[0m:\
      532    *      :COLOR 13 GRAY=\E[5;5;47m:\E[0m:\
      533    *
      534    * protop.ini
      535    *
      536    *    [WinChar Colors]
      537    *    color0=BLACK/WHITE         "NORMAL"
      538    *    color1=BLUE/WHITE          "INPUT, UNDERLINE"   
      539    *    color2=BLUE/WHITE          "MESSAGES, REVERSE"
      540    *    color3=RED/WHITE           "HIGHLITE, HELP"
      541    *    color4=RED/WHITE           "URGENT"
      542    *    color5=BLACK/WHITE         "URGENT"
      543    *    color6=RED/WHITE           "URGENT"
      544    *    color7=GREEN/WHITE         "URGENT"
      545    *    color8=YELLOW/WHITE        "URGENT"
      546    *    color9=BLUE/WHITE          "URGENT"
      547    *    
      548    *    ;NORMAL=WHITE/BLUE
      549    *    ;INPUT=BLACK/GRAY 
      550    *    ;MESSAGES=BLACK/GRAY 
      551    *    
      552    */
      553   
      554   if term matches "*xterm*" then
      555     clrterm = "5,6,9".                                                                            /* black, red & blue on a white background      */
      556    else if term = "co80" then
      557     /* clrterm = "5,9,6". */                                                                      /* black, red & gray on a white background      */
      558     clrterm = "5,6,9".                                                                            /* black, red & blue on a white background      */
      559    else if "TTY" <> "tty" then
      560     clrterm = "0,4,1".                                                                            /* black, red & blue on a white background      */
      561    else
      562     clrterm = "5,6,9".                                                                            /* black, red & gray on a white background      */
      563   
      564   define variable browseStart as integer no-undo initial 3.                                       /* line# where browsers can start displays      */
      565   define variable browseLines as integer no-undo.                                                 /* number of lines available for browsers       */
      566   
      567   define variable resultSet as handle no-undo.
      568   
      569   create dataset resultSet.
      570   
      571   /*** Install self as a session super-procedure
      572    ***
      573    ***/
      574   
      575   session:add-super-procedure( this-procedure ).
      576   
      577   subscribe to "protop_show"      anywhere run-procedure "protop_show".
      578   subscribe to "protop_display"   anywhere run-procedure "protop_display".
      579   subscribe to "protop_getReqStr" anywhere run-procedure "protop_getReqStr".
      580   subscribe to "resizeBrowse"     anywhere run-procedure "resizeBrowse".
      581   
      582   return.
      583   
      584   
      585   /** library of functions and procedures
      586    **
      587    **/
      588   
      589   
      590   function getColorNum returns integer ( colorCode as character ):
      591   
      592     define variable colorNum as integer no-undo.
      593     
      594     colorNum = integer( entry( lookup( colorCode, clrmap ), clrterm )) no-error.
      595   
      596     publish "logMsg" ( 8, substitute( "Looking for: &1 clrMap = &2 clrTerm = &3 result: &4", colorCode, clrMap, clrTerm, lookup( colorCode, clrmap ))).
      597   
      598     if error-status:error then 
      599      return 1.
      600     else
      601      return colorNum. 
      602   
      603   end.
      604   
      605   
      606   procedure getConfig:
      607   
      608     define input  parameter cfgName as character no-undo.
      609     define output parameter cfgCLOB as longchar  no-undo.
      610   
      611     define variable dName   as character no-undo.
      612     define variable respHdr as character no-undo.
      613   
      614     dName = search( cfgName ).                                                    /* first check the PROPATH                      */
      615   
      616     if dName = ? then dName = search( "ptdefs/" + cfgName ).                      /* maybe it is in a sub-dir?                    */
      617   
      618     if dName <> ? then                                                            /* didn't find a file -- maybe a URL?           */
      619       do:
      620         if dbgMode >= 3 then message now "reading" dName.
      621         copy-lob from file dName to cfgCLOB.                                      /* return a longchar                            */
      622       end.
      623      else                                                                         /* try dbappraise.com                           */
      624       do:
      625         message now "Could not find: ptdefs/" + cfgName view-as alert-box.
      626       end.
      627   
      628     return.
      629   
      630   end.
      631   
      632   
      633   function rowDisplay returns logical ( z as handle ):
      634   
      635     define buffer tt_browseColumnList for tt_browseColumnList.
      636   
      637     define variable hiliteAttr as character no-undo.
      638   
      639     if not valid-handle( z ) then
      640       do:
      641         publish "logMsg" ( 3, "Bogus browse handle in rowsDisplay!" ).
      642         return false.
      643       end.
      644   
      645     for each tt_browseColumnList where browseHandle = z and valid-handle( z ):
      646   
      647       hilite( tt_browseColumnList.bufferHandle, columnName, tt_browseColumnList.bufferHandle:buffer-field( columnName ):buffer-value, output hiliteAttr ).
      648   
      649       if hiliteAttr <> "" and valid-handle( columnHandle ) then
      650         do:
      651          
      652           if "TTY" = "tty" then
      653             columnHandle:dcolor  = getColorNum( hiliteAttr ).
      654            else
      655             columnHandle:fgcolor = getColorNum( hiliteAttr ).
      656         end.
      657   
      658     end.
      659   
      660     return true.
      661   
      662   end.
      663   
      664   
      665   function getBrowseColumnByName returns handle ( z as handle, n as character ):
      666   
      667     define variable c as handle no-undo.
      668   
      669     c = z:first-column.
      670   
      671     do while valid-handle( c ):
      672       if c:name = n then
      673         leave.
      674        else
      675         c = c:next-column.
      676     end.
      677   
      678     return c.
      679   
      680   end.
      681   
      682   
      683   function trackElement returns logical ( frmH as handle, elemH as handle, eName as character, proType as character, proFormat as character, horAlign as character, r as integer, c as integer, elemType as character ):
      684   
      685     define buffer tt_screenElement for tt_screenElement.
      686   
      687     find tt_screenElement where
      688       elementName   = eName and
      689       frameHandle   = frmH  and
      690       elementHandle = elemH
      691       no-error.
      692   
      693     if not available( tt_screenElement ) then
      694       do:
      695         create tt_screenElement.
      696         assign
      697           tt_screenElement.frameName     = frmH:name
      698           tt_screenElement.elementName   = eName
      699           tt_screenElement.elementRow    = r
      700           tt_screenElement.elementCol    = c
      701           tt_screenElement.elementType   = elemType
      702           tt_screenElement.frameHandle   = frmH
      703           tt_screenElement.elementHandle = elemH
      704           tt_screenElement.proType       = proType
      705           tt_screenElement.proFormat     = proFormat
      706           tt_screenElement.elementAlign  = horAlign
      707         .
      708       end.
      709   
      710     return true.
      711   
      712   end.
      713   
      714   
      715   function addLabel returns logical ( f as handle, wName as character, r as integer, c as integer, w as integer ):
      716   
      717     define variable t as handle no-undo.
      718   
      719     create text t.
      720     assign
      721       t:frame        = f
      722       t:name         = wName
      723       t:format       = substitute( "x(&1)", max( 1, w, length( wName )))
      724       t:row          = r
      725       t:col          = c
      726       t:screen-value = wName
      727       f:height-chars = max( r, f:height-chars )
      728       browseStart    = max( browseStart, f:row + f:height-chars + 1 )
      729     .
      730   
      731     trackElement( f, t, wName, "character", t:format, "right", r, c, "label" ).
      732   
      733     return true.
      734   
      735   end.
      736   
      737   
      738   function addDataElement returns logical ( f as handle, wName as character, r as integer, c as integer, w as integer, proType as character, proFormat as character, horAlign as character ):
      739   
      740     define variable t as handle no-undo.
      741   
      742     define variable pFmt as character no-undo.
      743   
      744     pFmt = proFormat.
      745     if pFmt = "" then pFmt = substitute( "x(&1)", max( 1, w )).
      746   
      747     create text t.
      748     assign
      749       t:frame        = f
      750       t:name         = wName
      751       t:width-chars  = w
      752       t:row          = r
      753       t:col          = c
      754       t:format       = substitute( "x(&1)", max( 1, w, length( wName )))
      755       t:screen-value = wName /* proType */ /* pFmt */                     /* handy for debugging layout, use PAUSE in protop.p    */
      756       f:height-chars = max( r, f:height-chars )
      757       browseStart    = max( browseStart, f:row + f:height-chars + 1 )
      758     .
      759   
      760     trackElement( f, t, wName, proType, pFmt, horAlign, r, c, "field" ).
      761   
      762     return true.
      763   
      764   end.
      765   
      766   
      767   procedure dynViewerInit:
      768   
      769     define input parameter f         as handle    no-undo.
      770     define input parameter dcName    as character no-undo.
      771     define input parameter ttName    as character no-undo.
      772     define input parameter evtName   as character no-undo.
      773     define input parameter dispOrder as integer   no-undo.
      774     define input parameter rMin      as integer   no-undo.
      775     define input parameter rMax      as integer   no-undo.
      776   
      777     define buffer tt_screenList for tt_screenList.
      778   
      779     define variable scrDef as handle no-undo.
      780   
      781     define variable q as handle  no-undo.
      782     define variable b as handle  no-undo.
      783   
      784     define variable i as integer no-undo.
      785     define variable r as integer no-undo.
      786     define variable c as integer no-undo.
      787     define variable w as integer no-undo.
      788   
      789     define variable dCLOB      as longchar  no-undo.
      790   
      791     define variable proFmt   as character no-undo.
      792     define variable proType  as character no-undo.
      793     define variable horAlign as character no-undo.
      794   
      795     define variable fName as character no-undo.
      796     define variable cText as character no-undo.
      797   
      798     define variable bx as handle  no-undo.
      799   
      800     define variable fillChar as character no-undo initial " ".            /* "." is useful for layout debugging...        */
      801   
      802     define variable cut1 as integer no-undo.
      803     define variable cut2 as integer no-undo.
      804   
      805     run getConfig( substitute( "&1.xml", dcName ), output dCLOB ).
      806   
      807     cut1 = index( dCLOB, 'file="' ).
      808     if cut1 > 0 then
      809       cut2 = index( dCLOB, 'columns="' ).
      810   
      811     if cut2 > 0 then
      812       cut2 = cut2 + 10 + index( substring( dCLOB, cut2 + 10, 10 ), '"' ).
      813   
      814     if dbgMode >= 5 and cut1 > 0 and cut2 > 0 then
      815       message
      816         dcName "removing:" cut1 "through" cut2 skip
      817         string( substring( dCLOB, cut1, ( cut2 - cut1 )))
      818        view-as
      819         alert-box
      820       .
      821   
      822     if cut1 > 0 and cut2 > 0 then
      823       substring( dCLOB, cut1, ( cut2 - cut1 )) = fill( " ", ( cut2 - cut1 )).
      824   
      825     create temp-table scrdef.
      826     scrDef:read-xml( "longchar", dCLOB, "empty", ?, ?, ?, ?  ).
      827   
      828     assign
      829       b      = scrDef:default-buffer-handle
      830       f:name = ttName
      831       f:row  = ( if evtName = "dbid" then 2 else 4 )
      832     .
      833   
      834   /* +++
      835    * run getConfig( substitute( "&1.xsd", ttName ), output dCLOB ).
      836    * create temp-table bx.
      837    * bx:read-xmlschema( "longchar", dCLOB, ?, ?, ?  ).
      838    */
      839   
      840     create query q.
      841   
      842     find tt_screenList where tt_screenList.ttName = ttName no-error.
      843     if not available( tt_screenList ) then
      844       do:
      845         create tt_screenList.
      846         assign
      847           tt_screenList.displayOrder  = dispOrder
      848           tt_screenList.screenName    = f:private-data
      849           tt_screenList.ttName        = ttName
      850           tt_screenList.dcName        = dcName
      851           tt_screenList.evtName       = evtName
      852           tt_screenList.frameHandle   = f
      853           tt_screenList.bufferHandle  = ?
      854           tt_screenList.queryHandle   = q
      855           tt_screenList.browseHandle  = ?                         /* there is no browse associated with a viewer                  */
      856           tt_screenList.screenType    = "viewer"
      857           tt_screenList.screenVisible = ( evtName = "dbid" )      /* initially only "dbid" is automatically visible               */
      858           tt_screenList.screenRow     = f:row
      859         .
      860       end.
      861   
      862     /* when we initialize the viewer fill in fields with the field name
      863      */
      864   
      865     q:set-buffers( b ).
      866     q:query-prepare( "for each " + scrDef:name ).
      867     q:query-open.
      868   
      869     q:get-next().
      870   
      871     do while q:query-off-end = false:
      872   
      873       i = i + 1.
      874   
      875       assign
      876         fName = b:buffer-field( "ControlName" ):buffer-value()
      877         cText = b:buffer-field( "ControlText" ):buffer-value()
      878         c     = integer( entry( 1, b:buffer-field( "ControlLocation" ):buffer-value()))
      879         r     = integer( entry( 2, b:buffer-field( "ControlLocation" ):buffer-value()))
      880         w     = integer( entry( 1, b:buffer-field( "ControlSize" ):buffer-value()))
      881       .
      882   
      883       assign
      884         proType  = b:buffer-field( "proType" ):buffer-value()
      885         horAlign = b:buffer-field( "HAlign" ):buffer-value()
      886         proFmt   = b:buffer-field( "proFormat" ):buffer-value()
      887       no-error.
      888   
      889       assign
      890         r = max( 1, r )
      891         c = max( 1, c )
      892       .
      893   
      894       if length( cText ) < w then cText = fill( fillChar, w - length( cText )) + cText.
      895   
      896       if index( fName, "_label" ) > 0 then
      897         addLabel( f, cText, r, c, w ). 
      898        else
      899         addDataElement( f, fName, r, c, w, proType, proFmt, horAlign ).
      900   
      901       q:get-next().
      902   
      903     end.
      904   
      905     delete object scrDef.
      906   
      907     /* do not delete object q -- it is persisted in tt_screenList for later usage */
      908   
      909     return. /* true. */
      910   
      911   end.
      912   
      913   
      914   procedure dynBrowserInit:
      915   
      916     define input parameter f         as handle    no-undo.
      917     define input parameter dcName    as character no-undo.
      918     define input parameter ttName    as character no-undo.
      919     define input parameter evtName   as character no-undo.
      920     define input parameter dispOrder as integer   no-undo.
      921     define input parameter rMin      as integer   no-undo.
      922     define input parameter rMax      as integer   no-undo.
      923   
      924     define buffer tt_screenList for tt_screenList.
      925   
      926     define variable dCLOB      as longchar  no-undo.
      927   
      928     define variable b as handle  no-undo.
      929     define variable q as handle  no-undo.
      930   
      931     find tt_screenList where tt_screenList.ttName = ttName no-error.
      932     if not available( tt_screenList ) then
      933       do:
      934   
      935         create query q.
      936   
      937         create tt_screenList.
      938         assign
      939           tt_screenList.displayOrder  = dispOrder
      940           tt_screenList.screenName    = f:private-data
      941           tt_screenList.ttName        = ttName
      942           tt_screenList.dcName        = dcName
      943           tt_screenList.evtName       = evtName
      944           tt_screenList.frameHandle   = f
      945           tt_screenList.queryHandle   = q                                 /* browsers need a query                */
      946           tt_screenList.browseHandle  = ?                                 /* defer until screen size is known     */
      947           tt_screenList.screenType    = "browser"
      948           tt_screenList.screenVisible = no
      949           tt_screenList.minRows       = rMin
      950           tt_screenList.maxRows       = rMax
      951         .
      952       end.
      953   
      954   /* +++
      955    * run getConfig( substitute( "&1.xsd", ttName ), output dCLOB ).
      956    * create temp-table b.
      957    * b:read-xmlschema( "longchar", dCLOB, ?, ?, ?  ).
      958    */
      959   
      960   /* +++
      961    * tt_screenList.bufferHandle = b:default-buffer-handle no-error.       /* +++ added no-error */        /* why do browsers have this but viewers do not?        */
      962    * q:set-buffers( b:default-buffer-handle ) no-error.                   /* +++ added no-error */
      963    */
      964   
      965     /* do not delete object q or b -- it is persisted in tt_screenList for later usage */
      966   
      967     return. /* true. */
      968   
      969   end.
      970   
      971   
      972   procedure dynViewerUpdate:
      973   
      974     define input parameter q as handle no-undo.
      975     define input parameter f as handle no-undo.
      976     define input parameter b as handle no-undo.
      977   
      978     define buffer tt_screenElement for tt_screenElement.
      979   
      980     define variable i as integer no-undo.                 /* tables               */
      981     define variable j as integer no-undo.                 /* fields               */
      982     define variable k as integer no-undo.                 /* fields in a buffer   */
      983   
      984     define variable r as integer no-undo.                 /* rows                 */
      985     define variable c as integer no-undo.                 /* columns              */
      986     define variable w as integer no-undo.                 /* width                */
      987   
      988     define variable ok as logical no-undo.
      989   
      990     define variable bufList   as character no-undo.
      991     define variable hiliteAttr as character no-undo.
      992   
      993     define variable x as handle no-undo.
      994   
      995     q:get-first().                                        /* where did q come from?       */
      996   
      997     do while not q:query-off-end:
      998   
      999       r = r + 1.
     1000   
     1001       do j = 1 to b:num-fields:
     1002   
     1003         c = c + 1.
     1004         x = b:buffer-field( j ).
     1005   
     1006         find tt_screenElement where frameName = b:name and elementName = x:name no-error.
     1007   
     1008         /* update a screen element
     1009          */
     1010   
     1011         if available( tt_screenElement ) then
     1012           do:
     1013   
     1014             /* I really should be ashamed of myself for hard-coding this dbLogName assignment :(  To say nothing of the shared variable...
     1015              */
     1016   
     1017             if elementName = "dbidLogName" then
     1018               ptDBName = x:buffer-value.
     1019   
     1020             hilite( b, elementName, x:buffer-value, output hiliteAttr ).
     1021    
     1022             if hiliteAttr <> "" then
     1023               do:
     1024                 if "TTY" = "tty" and valid-handle( tt_screenElement.elementHandle ) then
     1025                   tt_screenElement.elementHandle:dcolor  = getColorNum( hiliteAttr ).
     1026                  else
     1027                   tt_screenElement.elementHandle:fgcolor = getColorNum( hiliteAttr ).
     1028               end.
     1029              else
     1030               do:
     1031                 if "TTY" = "tty" and valid-handle( tt_screenElement.elementHandle ) then
     1032                   tt_screenElement.elementHandle:dcolor  = ?.
     1033                  else
     1034                   tt_screenElement.elementHandle:fgcolor = ?.
     1035               end.
     1036   
     1037             case tt_screenElement.proType:
     1038   
     1039              when "integer" then tt_screenElement.elementHandle:screen-value = string( integer( x:buffer-value ), tt_screenElement.proFormat ) no-error.
     1040              when "decimal" then tt_screenElement.elementHandle:screen-value = string( decimal( x:buffer-value ), tt_screenElement.proFormat ) no-error.
     1041              otherwise
     1042                do:
     1043                  if tt_screenElement.elementAlign = "Right" then
     1044                    tt_screenElement.elementHandle:screen-value =
     1045                      fill( " ", integer( tt_screenElement.elementHandle:width-chars ) - length( trim( x:buffer-value ))) +
     1046                      trim( x:buffer-value ).
     1047                   else if tt_screenElement.elementAlign = "Center" then
     1048                    tt_screenElement.elementHandle:screen-value =
     1049                      fill( " ", integer(( tt_screenElement.elementHandle:width-chars - length( trim( x:buffer-value ))) / 2 )) +
     1050                      trim( x:buffer-value ).
     1051                   else /* "left" */
     1052                    tt_screenElement.elementHandle:screen-value = trim( x:buffer-value ).
     1053                end.
     1054   
     1055             end.
     1056   
     1057             tt_screenElement.elementValue = tt_screenElement.elementHandle:screen-value.
     1058   
     1059             if error-status:num-messages > 0 then
     1060               do:
     1061                 publish "logMsg" ( 8, substitute( "Error rendering: &1 &2 &3 &4", x:name, x:buffer-value, tt_screenElement.proType, tt_screenElement.proFormat )).
     1062               end.
     1063   
     1064           end.
     1065   
     1066       end.
     1067   
     1068       q:get-next().
     1069   
     1070     end.
     1071   
     1072     return.
     1073   
     1074   end.
     1075   
     1076   
     1077   procedure dynBrowserUpdate:
     1078   
     1079     define input parameter q as handle no-undo.
     1080     define input parameter f as handle no-undo.
     1081     define input parameter b as handle no-undo.
     1082     define input parameter z as handle no-undo.
     1083   
     1084   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.1 AND PROVERSION >= "10.1C" &THEN
     1085     .
     1086   &ELSE
     1087     return.
     1088   &ENDIF
     1089   
     1090     define buffer tt_screenList for tt_screenList.
     1091     define buffer tt_browseColumnList for tt_browseColumnList.
     1092   
     1093     define variable i as integer no-undo.
     1094     define variable j as integer no-undo.
     1095   
     1096     define variable k as integer no-undo.                                 /* fields in a buffer                                   */
     1097     define variable c as integer no-undo.                                 /* column width                                         */
     1098     define variable w as integer no-undo.                                 /* frame width                                          */
     1099   
     1100     define variable xlist as character no-undo.                           /* fields to exclude from browsers                      */
     1101   
     1102     define variable needList  as logical   no-undo.                       /* do we need to create the list of fields?             */
     1103     define variable zField    as character no-undo.                       /* what field are we sorting on?                        */
     1104     define variable sortAsc   as logical   no-undo.                       /* ascending = yes, descending = no                     */
     1105   
     1106     define variable bf as handle no-undo.
     1107   
     1108     find tt_screenList where tt_screenList.ttName = b:name no-error.
     1109     if not available( tt_screenList ) then
     1110       do:
     1111         message "That's odd -- no tt_screenList for:" b:name view-as alert-box.
     1112         pause.
     1113         return.
     1114       end.
     1115   
     1116     if not valid-handle( z:query ) or not valid-handle( q ) then
     1117       do:
     1118         message "dynBrowserUpdate() - invalid query associated with browse:" b:name " q:valid?" valid-handle( q ).
     1119         pause.
     1120         return.
     1121       end.
     1122   
     1123     /* determine what field we are sorting on
     1124      */
     1125   
     1126     assign
     1127       zField  = tt_screenList.sortBy
     1128       sortAsc = ( if tt_screenList.sortDir = "Up" then true else false )
     1129     .
     1130   
     1131     if zField = "stackNum" then sortAsc = true.                           /* override default "descending" for numeric field      */
     1132   
     1133     if tt_screenList.sortFieldList = "" then needList = true.
     1134   
     1135     if needList = true or zField = "" then
     1136       do i = 1 to num-entries( q:index-information ):
     1137         if entry( i, q:index-information ) <> "WHOLE-INDEX" then
     1138           do:
     1139             if zField = "" then zField = replace( entry( i, q:index-information ), "-idx", "" ).  /* fieldName-idx naming convention...           */
     1140             j = 0.
     1141             do while true:
     1142               j = j + 1.
     1143               if b:index-information( j ) = ? then leave.
     1144               if needList then tt_screenList.sortFieldList =  tt_screenList.sortFieldList + ( if tt_screenList.sortFieldList = "" then "" else ",") + entry( 5, b:index-information( j )).
     1145               if b:index-information( j ) = sortField then
     1146                 do:
     1147                   sortAsc = ( entry( 6, b:index-information( j )) = "0" ).
     1148                   leave.
     1149                 end.
     1150             end.
     1151             leave.
     1152           end.
     1153       end.
     1154   
     1155     assign
     1156       tt_screenList.sortBy  = zField
     1157       tt_screenList.sortDir = ( if sortAsc then "Up" else "Down" )
     1158     .
     1159   
     1160     if z:num-columns = 0 then                                             /* we must need columns to be added!                    */
     1161       do:
     1162   
     1163         w = 0.                                                            /* width is 0 to start                                  */
     1164   
     1165         xlist = "xid,xvalid,xtime,ztime,cpLenSec".                        /* known unwanted fields                                */
     1166         do k = 1 to b:num-fields:                                         /* walk through the fields                              */
     1167           if b:buffer-field( k ):extent > 1 then                          /* suppress array fields                                */
     1168             xlist = xlist + "," + b:buffer-field( k ):name.
     1169           if b:buffer-field( k ):name begins "z" then                     /* suppress fields whose name beings with "z"           */
     1170             xlist = xlist + "," + b:buffer-field( k ):name.
     1171         end.
     1172   
     1173         z:add-columns-from( b, xlist ).                                   /* hide any "xid", "xvalid" or array fields             */
     1174   
     1175         do k = 1 to b:num-fields:                                         /* walk through the fields                              */
     1176   
     1177           if lookup( b:buffer-field( k ):name, xlist ) > 0 then next.     /* exclude "xid" etc. from the width calculation        */
     1178   
     1179           c = ( max(                                                      /* the label might be wider than the data format        */
     1180                 b:buffer-field( k ):width-chars,
     1181                 length( b:buffer-field( k ):label )
     1182               )).
     1183   
     1184           w = w + c + 1.                                                  /* account for the space between each field...          */
     1185   
     1186           /* set up a mapping table so that row-display triggers can find
     1187            * the browse columns
     1188            */
     1189   
     1190           bf = b:buffer-field( k ).                                       /* 10.0a barfs without this...                          */
     1191   
     1192           find tt_browseColumnList where browseName = b:name and columnName = bf:name no-error.
     1193           if not available( tt_browseColumnList ) then create tt_browseColumnList.
     1194           assign
     1195             tt_browseColumnList.columnHandle = getBrowseColumnByName( z, b:buffer-field( k ):name )
     1196             tt_browseColumnList.browseName   = b:name
     1197             tt_browseColumnList.columnName   = b:buffer-field( k ):name
     1198             tt_browseColumnList.columnWidth  = c
     1199             tt_browseColumnList.browseHandle = z
     1200             tt_browseColumnList.bufferHandle = b
     1201           .
     1202   
     1203         end.
     1204   
     1205         assign
     1206           w = w + 4                                                       /* the box plus the useless "selected" indicator...     */
     1207           tt_screenList.frameHandle:width-chars  = w
     1208           tt_screenList.browseHandle:width-chars = w
     1209         .
     1210   
     1211         if w < 160 and dbgMode >= 3 then
     1212           do:
     1213             message "narrow frame:" w view-as alert-box.
     1214           end.
     1215   
     1216         if w > 160 and dbgMode >= 3 then
     1217           do:
     1218             publish "logMsg" ( 3, substitute( "&1 > 160 &2", w, tt_screenList.frameHandle:name )).
     1219           end.
     1220   
     1221       end.
     1222   
     1223     /* show which column we're sorting the browse by
     1224      */
     1225   
     1226     do k = 1 to b:num-fields:                                             /* walk through the fields                              */
     1227   
     1228       bf = b:buffer-field( k ).                                           /* 10.0a barfs without this...                          */
     1229   
     1230       find tt_browseColumnList where browseName = b:name and columnName = bf:name no-error.
     1231       if not available( tt_browseColumnList ) or not valid-handle( tt_browseColumnList.columnHandle ) then next.
     1232   
     1233   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.1 AND PROVERSION >= "10.1B" &THEN
     1234       if tt_browseColumnList.columnName = tt_screenList.sortBy then
     1235         tt_browseColumnList.columnHandle:sort-ascending = sortAsc.
     1236        else
     1237         tt_browseColumnList.columnHandle:sort-ascending = ?.
     1238   &ENDIF
     1239   
     1240     end.
     1241   
     1242     /* "SYSTEM ERROR: Memory violation. (49)" occasionally comes from the following block of code without any apparent rhyme or reason
     1243      */
     1244   
     1245     if tt_screenList.screenVisible = yes then
     1246       do:
     1247         if f:hidden = yes then                                            /* if we are already visible don't do anything          */
     1248           assign
     1249             f:hidden  = no
     1250             z:hidden  = no
     1251             f:visible = yes
     1252             z:visible = yes
     1253           no-error.
     1254       end.
     1255      else
     1256       do:
     1257         if f:hidden = no then                                             /* if we are already invisible don't do anything        */
     1258           assign
     1259             z:visible = no
     1260             f:visible = no
     1261             z:hidden  = yes
     1262             f:hidden  = yes
     1263           no-error.
     1264       end.
     1265   
     1266     if "TTY" <> "tty" then                   /* this must come *after* the block above!                              */
     1267       assign                                              /* it seems odd -- wouldn't it be better to shut off the scroll-bar     */
     1268         z:scrollbar-vertical = false                      /* while we are still hidden?                                           */
     1269       .
     1270   
     1271     return.
     1272   
     1273   end.
     1274   
     1275   
     1276   /* read-xml or read-json the data & map xml/json elements to dynamic screen elements...
     1277    */
     1278   
     1279   function dynScreenUpdate returns logical ( data as longchar ):
     1280   
     1281     define buffer tt_screenList for tt_screenList.
     1282   
     1283     define variable q as handle  no-undo.
     1284     define variable b as handle  no-undo.
     1285     define variable f as handle  no-undo.
     1286     define variable z as handle  no-undo.
     1287   
     1288     define variable i as integer no-undo.                 /* tables               */
     1289     define variable j as integer no-undo.                 /* fields               */
     1290     define variable k as integer no-undo.                 /* fields in a buffer   */
     1291   
     1292     define variable r as integer no-undo.                 /* rows                 */
     1293     define variable c as integer no-undo.                 /* columns              */
     1294     define variable w as integer no-undo.                 /* width                */
     1295   
     1296     define variable ok as logical no-undo.
     1297   
     1298     define variable bufList   as character no-undo.
     1299     define variable zField    as character no-undo.
     1300   
     1301     /* Issue Number: OE00197649
     1302      * Can't READ-JSON into a nameless dynamic dataset
     1303      *
     1304      * The READ-JSON method fails when called on a dynamic ProDataSet that does
     1305      * not have it's NAME attribute set, but does have buffers attached via the
     1306      * SET-BUFFERS() method.
     1307      *
     1308      */
     1309   
     1310   /*** +++
     1311    *
     1312    *  assign
     1313    *    resultSet:name = "ProDataSet"                                     /* the default ProdDataSet name                 */
     1314    *    ok = resultSet:set-buffers( "" )
     1315    *  no-error.
     1316    *
     1317    *  /* the idea is to pre-populate the dataset with the buffer handles
     1318    *   *
     1319    *   */
     1320    *
     1321    *  for each tt_screenList:                                             /* print-screen support                         */
     1322    *    if valid-handle( tt_screenList.bufferHandle ) then
     1323    *      resultSet:add-buffer( tt_screenList.bufferHandle ).
     1324    *     else
     1325    *      publish "logMsg" ( 3, substitute( "Invalid buffer handle in tt_screenList: &1", tt_screenList.ttName )).
     1326    *  end.
     1327    *
     1328    *  /* slurp the ProDataSet into resultSet
     1329    *   *
     1330    *   * trapping errors would be helpful -- but seems difficult... if not out and out impossible :(
     1331    *   *
     1332    *   */
     1333    *
     1334    *  i = 0 no-error.
     1335    *
     1336    *  if index( data, "<?xml " ) = 1 then
     1337    *    resultSet:read-xml( "longchar", data, "empty", ?, ?, ?, ? ).      /* prevents v9 support                          */
     1338    *   else if index( data, '~{"ProDataSet":' ) = 1 then
     1339    *    do:
     1340    *
     1341    * &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.2 AND PROVERSION >= "10.2B" &THEN
     1342    *      resultSet:read-json( "longchar", data, "empty" ) no-error.      /* JSON is very delicate...                     */
     1343    * &ELSE
     1344    *      message
     1345    *        "Support for JSON in the client interface requires 10.2B or higher." skip
     1346    *        'You might try adding export SENDTYPE="XML" to bin/protop'
     1347    *        view-as alert-box
     1348    *      .
     1349    *      quit.
     1350    * &ENDIF
     1351    *
     1352    *      /* unfortunately this doesn't actually catch anything interesting :(
     1353    *       */
     1354    *
     1355    *      if dbgMode >= 5 and error-status:num-messages > 0 then
     1356    *        do:
     1357    *          do i = 1 to error-status:num-messages:
     1358    *            message now "read-json:" error-status:get-number( i ) error-status:get-message( i ).
     1359    *          end.
     1360    *          pause.
     1361    *        end.
     1362    *
     1363    *    end.
     1364    *   else
     1365    *    do:
     1366    *      publish "logMsg" ( 1, "Invalid data passed to dynScreenUpdate" ).
     1367    *      return false.
     1368    *    end.
     1369    *
     1370    * +++ ***/
     1371   
     1372     /* match up the buffers in the ProDataSet with the visible viewers & browsers
     1373      */
     1374   
     1375     loop:
     1376   
     1377   /* +++
     1378    *  do i = 1 to resultSet:num-buffers:
     1379    *    b = resultSet:get-buffer-handle( i ).
     1380    * +++ */
     1381   
     1382     do i = 1 to hDataSet:num-buffers:
     1383       b = hDataSet:get-buffer-handle( i ).
     1384       bufList = substitute( "&1&2&3", bufList, min( ",", bufList ), b:name ).
     1385       find tt_screenList where tt_screenList.ttName = b:name no-error.
     1386       if not available( tt_screenList ) then
     1387         next loop.
     1388        else
     1389         tt_screenList.bufferHandle = b.
     1390     end.
     1391   
     1392     /* message i "buffers slurped:" bufList view-as alert-box.
     1393      */
     1394   
     1395     create query q.
     1396     q:forward-only = no.
     1397   
     1398   /* +++
     1399    *  do i = 1 to resultSet:num-buffers:
     1400    *    b = resultSet:get-buffer-handle( i ).
     1401    * +++ */
     1402   
     1403     do i = 1 to hDataSet:num-buffers:
     1404       b = hDataSet:get-buffer-handle( i ) no-error.                       /* +++ added no-error */
     1405       if valid-handle( b ) and b:name matches "*_Info" then
     1406         do:
     1407           find tt_screenList where tt_screenList.ttName = substring( b:name, 1, index( b:name, "_Info" ) - 1 ) no-error.
     1408           if available tt_screenList and valid-handle( b:default-buffer-handle ) then
     1409             do:
     1410   
     1411               q:set-buffers( b ) no-error.                                /* +++ added no-error */
     1412               q:query-prepare( "preselect each " + b:name ) no-error.     /* +++ added no-error */
     1413               q:query-open no-error.                                      /* +++ added no-error */
     1414               q:get-first() no-error.                                     /* +++ added no-error */
     1415   
     1416               if b:available and valid-handle( tt_screenList.browseHandle ) then
     1417                 do:
     1418                   /* message             b:buffer-field( "infoString" ):buffer-value view-as alert-box. */
     1419                   tt_screenList.browseHandle:title = " " + b:buffer-field( "infoString" ):buffer-value + " " no-error. /* +++ added no-error */
     1420                 end.
     1421   
     1422               q:query-close() no-error.
     1423   
     1424             end.
     1425         end.
     1426     end.
     1427   
     1428     q:query-close() no-error.
     1429     delete object q.
     1430   
     1431     /* process the viewers & browsers in the order that they are on the screen (by screen row)
     1432      */
     1433   
     1434     bufList = "".
     1435   
     1436     for each tt_screenList
     1437        where tt_screenList.screenVisible = yes
     1438         by tt_screenList.displayOrder:
     1439   
     1440       f = tt_screenList.frameHandle.
     1441   
     1442       assign ok = true no-error.
     1443   
     1444       b = ?.
     1445       if valid-handle( tt_screenList.bufferHandle ) then b = tt_screenList.bufferHandle.
     1446   
     1447       if not valid-handle( b ) then next.
     1448   
     1449       /* do NOT do this! it closes the *previous* iteration's query!  bad idea if that was a browse window :(     
     1450        * it will result in all but the last browse being empty
     1451        *
     1452        *** q:query-close() no-error.
     1453        *
     1454        */
     1455   
     1456       if tt_screenList.screenType = "browser" then
     1457         do:
     1458   
     1459           z = tt_screenList.browseHandle.
     1460   
     1461           if not valid-handle( z ) then                   /* and lookup( tt_screenList.dcName, alwaysGrab ) > 0 */
     1462             do:
     1463               message "dynScreenUpdate() - missing browse widget!" tt_screenList.ttName.
     1464               /* pause. */
     1465               next.
     1466             end.
     1467   
     1468   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.1 AND PROVERSION >= "10.1C" &THEN
     1469   
     1470           if not valid-handle( z:query ) or not valid-handle( tt_screenList.queryHandle ) then
     1471             do:
     1472               message
     1473                 "dynScreenUpdate() - invalid query associated with browse:" b:name
     1474                 " z:" valid-handle( z )
     1475                 " zq:" valid-handle( tt_screenList.queryHandle )
     1476               .
     1477               pause.
     1478               next.
     1479             end.
     1480   
     1481   &ENDIF
     1482   
     1483         end.
     1484   
     1485       zField = "".
     1486       if tt_screenList.sortBy <> "" then
     1487         zField = substitute( "by &1 &2", tt_screenList.sortBy, ( if tt_screenList.sortDir = "Up" then "" else "descending" )).
     1488   
     1489       if b:name = "tt_pasoeInfo" then
     1490         zField = "by xid".
     1491   
     1492       q =  tt_screenList.queryHandle.
     1493   
     1494       if not valid-handle( q ) then
     1495         do:
     1496           message "dynScreenUpdate() - WTF? q is invalid?".
     1497           pause.
     1498           next.
     1499         end.
     1500   
     1501       assign ok = true no-error.
     1502   
     1503       q:query-close() no-error.
     1504       q:set-buffers( b ) no-error.
     1505       q:query-prepare( "for each " + b:name + " " + zField ) no-error.
     1506   
     1507       if error-status:num-messages > 0 then                               /* data collector did not return tt?                    */
     1508         do:
     1509           do i = 1 to error-status:num-messages:
     1510             message "query-prepare( for each" b:name zField ")" error-status:get-number( i ) error-status:get-message( i ) view-as alert-box.
     1511           end.
     1512           next.
     1513         end.
     1514   
     1515       assign ok = true no-error.
     1516   
     1517       q:query-open() no-error.
     1518   
     1519       if error-status:num-messages > 0 then
     1520         do:
     1521           do i = 1 to error-status:num-messages:
     1522             message "query-open()" b:name zField error-status:get-number( i ) error-status:get-message( i ) view-as alert-box.
     1523           end.
     1524           next.
     1525         end.
     1526   
     1527       tt_screenList.resultRows = q:num-results.
     1528   
     1529       bufList = substitute( "&1&2&3", bufList, min( ",", bufList ), b:name ).
     1530   
     1531       if tt_screenList.screenType = "browser" then
     1532   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.1 AND PROVERSION >= "10.1C" &THEN
     1533         run dynBrowserUpdate( q, f, b, z ).
     1534   &ELSE
     1535         .
     1536   &ENDIF
     1537        else if tt_screenList.screenType = "viewer" then
     1538         run dynViewerUpdate( q, f, b ).
     1539   
     1540     end. /* for each tt_screenList ... */
     1541   
     1542     return true.
     1543   
     1544   end.
     1545   
     1546   
     1547   procedure protop_getReqStr:
     1548   
     1549     define input-output parameter reqString as character no-undo.
     1550   
     1551     define variable cmd as character no-undo.
     1552   
     1553     define variable i as integer no-undo.
     1554   
     1555     for each tt_screenList where tt_screenList.screenVisible = yes:
     1556       cmd = cmd + ( if cmd > "" then "," else "" ) + tt_screenList.dcName.
     1557     end.
     1558   
     1559     /* always grab certain data collectors -- whether they are visible or not
     1560      */
     1561   
     1562     do i = 1 to num-entries( alwaysGrab ):
     1563       if lookup( entry( i, alwaysGrab ), cmd ) < 1 then cmd = entry( i, alwaysGrab ) + "," + cmd. /* print screen support */
     1564     end.
     1565   
     1566     publish "logMsg" ( 9, substitute( "Command = &1", cmd )).
     1567   
     1568     reqString = cmd.
     1569   
     1570     return.
     1571   
     1572   end.
     1573   
     1574   
     1575   /* make sure that viewers and browsers are properly associated with one another
     1576    */
     1577   
     1578   procedure protop_show:
     1579   
     1580     define input parameter evtName  as character no-undo.
     1581   
     1582     define buffer tt_screenList for tt_screenList.
     1583     define buffer xtt_screenList for tt_screenList.
     1584   
     1585     define variable v as logical no-undo.
     1586   
     1587     find tt_screenList where tt_screenList.evtName = evtName no-error.
     1588     
     1589     if not available( tt_screenList ) then
     1590       do:
     1591         publish "logMsg" ( 3, substitute( 'unknown event: "&1"', evtName )).
     1592         return.
     1593       end.
     1594   
     1595     if lookup( evtName, "usrtblact,usridxact,usrstack,usrother" ) > 0 then
     1596       do:
     1597         find xtt_screenList where xtt_screenList.evtName = "userinfo".
     1598         if  xtt_screenList.screenVisible = no then return.
     1599       end.
     1600   
     1601     if tt_screenList.screenType = "browser" then
     1602       do:
     1603   
     1604         tt_screenList.screenVisible = not( tt_screenList.screenVisible ).
     1605   
     1606         /* keep "latches", "resources" and "txe" bound together -- some odd things happen if "latches" is displayed first so
     1607          * jump thorugh some hoops and do "resources" 1st.  the 2nd arg to protop_display() is correct as "tt" NOT "xtt"!
     1608          */
     1609   
     1610         if tt_screenList.evtName = "latches" then
     1611           do:
     1612   
     1613             find xtt_screenList where xtt_screenList.evtName = "resources".
     1614             run protop_display( xtt_screenList.ttName, tt_screenList.screenVisible ).
     1615             run protop_display(  tt_screenList.ttName, tt_screenList.screenVisible ).
     1616   
     1617             find xtt_screenList where xtt_screenList.evtName = "txe".
     1618             run protop_display( xtt_screenList.ttName, tt_screenList.screenVisible ).
     1619             run protop_display(  tt_screenList.ttName, tt_screenList.screenVisible ).
     1620   
     1621           end.
     1622   
     1623   /*** this was a reasonable thing to do before the blocker data was added to the notes for the blocked session - maybe make it an option if anyone cares about it?
     1624    *     else if tt_screenList.evtName = "blocked" then
     1625    *      do:
     1626    *        find xtt_screenList where xtt_screenList.evtName = "blocker".
     1627    *        run protop_display( xtt_screenList.ttName, tt_screenList.screenVisible ).
     1628    *        run protop_display(  tt_screenList.ttName, tt_screenList.screenVisible ).
     1629    *      end.
     1630    *     else if tt_screenList.evtName = "blocker" then
     1631    *      do:
     1632    *        find xtt_screenList where xtt_screenList.evtName = "blocked".
     1633    *        run protop_display(  tt_screenList.ttName, tt_screenList.screenVisible ).
     1634    *        run protop_display( xtt_screenList.ttName, tt_screenList.screenVisible ).
     1635    *      end.
     1636    ***/
     1637   
     1638          else if tt_screenList.evtName = "apsvstat" then
     1639           do:
     1640             find xtt_screenList where xtt_screenList.evtName = "apsvdet".
     1641             run protop_display( xtt_screenList.ttName, tt_screenList.screenVisible ).
     1642             run protop_display(  tt_screenList.ttName, tt_screenList.screenVisible ).
     1643           end.
     1644          else if tt_screenList.evtName = "apsvdet" then
     1645           do:
     1646             find xtt_screenList where xtt_screenList.evtName = "apsvstat".
     1647             run protop_display(  tt_screenList.ttName, tt_screenList.screenVisible ).
     1648             run protop_display( xtt_screenList.ttName, tt_screenList.screenVisible ).
     1649           end.
     1650   
     1651          else
     1652           run protop_display( tt_screenList.ttName, tt_screenList.screenVisible ).
     1653   
     1654       end.
     1655      else if tt_screenList.screenType = "viewer" then
     1656       do:
     1657   
     1658         browseStart = 0.
     1659   
     1660         for each xtt_screenList where xtt_screenList.screenType = "viewer" by xtt_screenList.displayOrder:
     1661   
     1662           if xtt_screenList.evtName = "DBId" then
     1663             assign
     1664               xtt_screenList.screenVisible        = yes
     1665               xtt_screenList.frameHandle:hidden   = no
     1666               xtt_screenList.frameHandle:visible  = yes
     1667               browseStart = ( xtt_screenList.frameHandle:row + xtt_screenList.frameHandle:height-chars + 1 )
     1668             .
     1669            else if xtt_screenList.evtName = evtName then
     1670             assign
     1671               xtt_screenList.screenVisible        = not ( xtt_screenList.screenVisible )
     1672               xtt_screenList.frameHandle:hidden   = not ( xtt_screenList.screenVisible )
     1673               xtt_screenList.frameHandle:visible  = xtt_screenList.screenVisible
     1674               browseStart = ( xtt_screenList.frameHandle:row + xtt_screenList.frameHandle:height-chars + 1 ) when xtt_screenList.screenVisible = yes
     1675             .
     1676            else
     1677             assign
     1678               xtt_screenList.screenVisible        = no
     1679               xtt_screenList.frameHandle:hidden   = yes
     1680               xtt_screenList.frameHandle:visible  = no
     1681             .
     1682   
     1683         end.
     1684   
     1685         /* userInfo is special -- it hides all unrelated browsers and opens its own set of confederates
     1686          */
     1687   
     1688         if tt_screenList.evtName = "userinfo" then
     1689           do:
     1690   
     1691             for each xtt_screenList where xtt_screenList.screenType = "browser":
     1692   
     1693               if lookup( xtt_screenList.evtName, "usrtblact,usridxact,usrstack,usrother" ) = 0 then
     1694                 assign
     1695                   xtt_screenList.screenVisible        = no                /* hide browsers that are not related to userInfo       */
     1696                   xtt_screenList.frameHandle:hidden   = yes
     1697                   xtt_screenList.frameHandle:visible  = no
     1698                 .
     1699                else
     1700                 assign
     1701                   xtt_screenList.screenVisible        = yes               /* reveal browsers that are related to userInfo         */
     1702                   xtt_screenList.frameHandle:hidden   = no
     1703                   xtt_screenList.frameHandle:visible  = yes
     1704                 .
     1705   
     1706             end.
     1707   
     1708           end.
     1709          else
     1710           do:
     1711   
     1712             for each xtt_screenList                                       /* hide the userInfo associated browses         */
     1713                 where
     1714                   xtt_screenList.screenType = "browser" and
     1715                   lookup( xtt_screenList.evtName, "usrtblact,usridxact,usrstack,usrother" ) > 0:
     1716   
     1717               assign
     1718                 xtt_screenList.screenVisible        = no                  /* hide the userInfo associated browses         */
     1719                 xtt_screenList.frameHandle:hidden   = yes
     1720                 xtt_screenList.frameHandle:visible  = no
     1721               .
     1722             end.
     1723   
     1724           end.
     1725   
     1726         if not available( tt_screenList ) then
     1727           publish "logMsg" ( 1, substitute( "No tt_screenlist! &1", evtName )).
     1728   
     1729         run protop_display( tt_screenList.ttName, tt_screenList.screenVisible ).
     1730   
     1731       end.
     1732      else
     1733       do:
     1734         publish "logMsg" ( 1, substitute( "Unknown screen type: &1", tt_screenList.screenType )).
     1735       end.
     1736   
     1737     return.
     1738   
     1739   end.
     1740   
     1741   
     1742   procedure protop_display:
     1743   
     1744     define input parameter ttName   as character no-undo.
     1745     define input parameter scrState as logical   no-undo.
     1746   
     1747     define buffer tt_screenList for tt_screenList.
     1748   
     1749     define variable s as integer no-undo.
     1750     define variable v as integer no-undo.
     1751     define variable h as integer no-undo.
     1752     define variable r as integer no-undo.
     1753     define variable n as integer no-undo.
     1754     define variable d as integer no-undo.
     1755     define variable t as integer no-undo.
     1756   
     1757     define variable i as integer no-undo.
     1758     define variable x as integer no-undo.
     1759     define variable y as integer no-undo initial 0.
     1760   
     1761     define variable q as handle  no-undo.
     1762     define variable b as handle  no-undo.
     1763     define variable f as handle  no-undo.
     1764     define variable z as handle  no-undo.
     1765   
     1766     define variable xDebug as logical no-undo initial no.
     1767   
     1768     find tt_screenList where tt_screenList.ttName = ttName no-error.
     1769     if available( tt_screenList ) then
     1770       do:
     1771         tt_screenList.screenVisible = scrState.
     1772         if scrState = no then
     1773           assign
     1774             tt_screenList.frameHandle:hidden  = yes
     1775             tt_screenList.frameHandle:visible = no
     1776           .
     1777       end.
     1778   
     1779     for each tt_screenList where tt_screenList.screenType = "browser":
     1780       if tt_screenList.screenVisible = yes then s = s + 1.
     1781       if tt_screenList.screenVisible = yes and lookup( tt_screenList.evtName, "latches,resources,txe" ) > 0 then x = x + 1.
     1782       assign
     1783         tt_screenList.frameHandle:hidden   = yes
     1784         tt_screenList.frameHandle:visible  = no
     1785       .
     1786       if valid-handle( tt_screenList.browseHandle ) then
     1787         assign
     1788           tt_screenList.browseHandle:hidden  = yes
     1789           tt_screenList.browseHandle:visible = no
     1790         .
     1791     end.
     1792   
     1793   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.1 AND PROVERSION >= "10.1C" &THEN
     1794     .
     1795   &ELSE
     1796     return.
     1797   &ENDIF
     1798   
     1799     if x >= 2 then s = ( s - ( x - 1 )).                          /* if both "latches" and "resources" or "txe" are visible only count one of them        */
     1800                                                                   /* blocked & blocker are NOT beside each other - so no funny business   */
     1801     browseStart = 3.
     1802   
     1803     v = 0.
     1804     for each tt_screenList where tt_screenList.screenType = "viewer" and tt_screenList.screenVisible = yes by tt_screenList.displayOrder:
     1805       browseStart = ( tt_screenList.frameHandle:row + tt_screenList.frameHandle:height-chars + 1 ).
     1806       v = v + 1.
     1807     end.
     1808   
     1809     if s < 1 then
     1810       do:
     1811   
     1812         /* message "Nothing to see here!" view-as alert-box. */
     1813   
     1814         if pt_first = no and v = 1 then                           /* v = 1 is the screen header                                   */
     1815           publish "protop_command" ( "?" ).
     1816   
     1817         return.                                                   /* nothing more to do!                                          */
     1818   
     1819       end.
     1820   
     1821     if pt_first = yes then pt_first = no.
     1822   
     1823     browseLines = ( screen-lines - browseStart ) + 1. 
     1824   
     1825     /* if there are more than 2 browsers shift the starting row upwards
     1826      */
     1827   
     1828     if s > 2 then
     1829       assign
     1830         browseStart = browseStart - 1                             /* eliminate the blank line between viewers and browsers        */
     1831         browseLines = browseLines + 1                             /* and add a line available for display                         */
     1832       .
     1833   
     1834     assign                                                        /* overlapping boxes put s - 1 lines back in play...            */
     1835       h = truncate(( browseLines + ( s - 1 )) / s, 0 )
     1836       r = ( browseLines + ( s - 1 )) modulo s                     /* remainder rows -- to dole out one at a time                  */
     1837     .
     1838   
     1839     d = 0.
     1840     for each tt_screenList where tt_screenList.screenType = "browser" and tt_screenList.screenVisible = yes and tt_screenList.evtName <> "resources":
     1841       if ( tt_screenList.maxRows > 0 ) and ( tt_screenList.maxRows < h ) then
     1842         assign
     1843           d = d + 1                                               /* how many row donors are there?                               */
     1844           r = r + ( h - tt_screenList.maxRows )                   /* donate excess rows to the remainder pool                     */
     1845         .
     1846     end.
     1847   
     1848     t = ( s - d ).                                                /* takers = screens - donors                                    */
     1849   
     1850     if ( h < 6 ) then                                             /* we nust be able to display at least 2 rows                   */
     1851       do:                                                         /* top box + label + underline + bottom box = 4                 */
     1852         message                                                   /* so we need at least 6 rows available...                      */
     1853              "There are too many browsers being displayed!" skip
     1854              skip(1)
     1855              "screenLines:" screen-lines skip
     1856              "browseStart:" browseStart skip
     1857              "browseLines:" browseLines skip
     1858               "  #visible:" s skip
     1859               "new height:" h skip
     1860               "extra rows:" r skip
     1861              skip(1)
     1862              "if you really want to display that much" skip
     1863              "stuff, restart with a taller window!" skip
     1864           view-as alert-box
     1865         .
     1866         /* return. */
     1867         quit.
     1868       end.
     1869   
     1870     if xDebug = yes then
     1871       do:
     1872         message screen-lines browseStart browseLines s h r view-as alert-box.
     1873       end.
     1874   
     1875   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.1 AND PROVERSION >= "10.1C" &THEN
     1876   
     1877     /* "s" re-purposed... who thought that was a good idea?
     1878      */
     1879   
     1880     s = browseStart.
     1881   
     1882     for each tt_screenList where tt_screenList.screenType = "browser" and tt_screenList.screenVisible = yes
     1883           by tt_screenList.displayOrder:
     1884   
     1885       /* size each browse -- try to use the screen space efficiently
     1886        */
     1887   
     1888       if ( tt_screenList.maxRows > 0 ) and ( tt_screenList.maxRows < h ) then
     1889         n = tt_screenList.maxRows.                                                /* max *data* rows - doesn't include decorations */
     1890        else
     1891         do:
     1892           if tt_screenList.evtName <> "resources" then
     1893             do:
     1894               n = h.                                                              /* standard height                              */
     1895               x = truncate(( r / t ), 0 ).                                        /* how big an extra chunk to take               */
     1896               /* if ( r / t ) > truncate(( r / t ), 0 ) then x = x + 1. */        /* favors earlier screen orders                 */
     1897               if r > 0 then                                                       /* dole out remainder rows                      */
     1898                 assign
     1899                   n = n + x                                                       /* take an additional chunk of rows             */
     1900                   r = r - x                                                       /* decrement remainder rows                     */
     1901                   t = t - 1                                                       /* decrement the number of remaining "takers"   */
     1902                 .
     1903             end.
     1904         end.
     1905   
     1906       publish "logMsg" ( 9, substitute( "row &1", s )).
     1907   
     1908       if ( n + s ) >= screen-lines then
     1909         publish "logMsg" ( 9, substitute( "trying to make &1 too big? &2 + &3 >= &4", f:name, n, s, screen-lines )).
     1910   
     1911       assign
     1912         f = tt_screenList.frameHandle
     1913         z = tt_screenList.browseHandle
     1914         tt_screenList.screenRow = s
     1915       .
     1916   
     1917       assign ok = yes no-error.
     1918   
     1919       assign
     1920         f:hidden       = yes
     1921         f:visible      = no
     1922         f:height-chars = n                                                /* change height *before* row!                          */
     1923         f:row          = s
     1924       no-error.
     1925    
     1926       /* latches, resources and txe */
     1927   
     1928       if tt_screenList.evtName <> "latches" and tt_screenList.evtName <> "resources" then
     1929         s = s + n - 1.                                                    /* "resources" on the same line as "latches"            */
     1930   
     1931       if valid-handle( z ) and z:height-chars <> n then
     1932         do:
     1933           publish "logMsg" ( 9, substitute( "Deleting browse &1", tt_screenList.evtName )).
     1934           /* delete object z:query no-error.      */                      /* resizing seems to require a new browse object?       */
     1935           delete object z no-error.                                       /* resizing seems to require a new browse object?       */
     1936           publish "logMsg" ( 9, "Success!" ).
     1937         end.
     1938   
     1939       if error-status:num-messages > 0 then
     1940         do i = 1 to error-status:num-messages:
     1941           publish "logMsg" ( 1, substitute( "Error: &1 &2", error-status:get-number(i), error-status:get-message(i))).
     1942         end.
     1943   
     1944       if not valid-handle( z ) then
     1945         do:
     1946   
     1947           create browse z assign                                  /* not available in ChUI until 10.1c                    */
     1948             frame        = f
     1949             title        = " " + f:private-data + " "
     1950             name         = f:name
     1951             width-chars  = 4                                      /* this is just an initial value -- it will change      */
     1952             read-only    = yes
     1953             hidden       = yes
     1954             visible      = no
     1955   /*        box          = no             */                      /* BOX is not a settable attribute for browse widgets   */
     1956           .
     1957   
     1958           if "TTY" <> "tty" then
     1959             assign
     1960               z:scrollbar-vertical   = false
     1961               z:row-markers          = no                         /* has no impact in ChUI                                */
     1962               z:manual-highlight     = yes                        /* has no impact in ChUI                                */
     1963   /*          z:box = no                          */              /* seems to do nothing                                  */
     1964   /*          z:focused-row-selected = no         */              /* Error (4052) "not a setable attribute"               */
     1965             .
     1966   
     1967         end.
     1968   
     1969       if not valid-handle( tt_screenList.queryHandle ) then
     1970         do:
     1971           message "protop_display() - tt_screenList.queryHandle is bogus?" dcName.
     1972           pause.
     1973         end.
     1974   
     1975       assign
     1976         tt_screenList.browseHandle = z
     1977         f:hidden       = yes
     1978         f:visible      = no
     1979         z:hidden       = yes
     1980         z:visible      = no
     1981         z:query        = tt_screenList.queryHandle
     1982   /*    z:height-chars = n - 0 */                                 /* 0, nothing seems to change it                        */
     1983         z:down         = max( 3, n - 4 )                          /* 4 = overlapping boxes, 5 = non-overlapping           */      /* 2 box lines, label text and a separator line         */
     1984       no-error.
     1985   
     1986       if not valid-handle( z:query ) then
     1987         do:
     1988           message "protop_display() - malformed browse, bad (or empty) query:" tt_screenList.bufferHandle:name.
     1989           /*** pause. ***/
     1990         end.
     1991   
     1992       if "TTY" <> "tty" then                         /* just in case someone runs this on a GUI client...    */
     1993         assign
     1994   /*      z:bgcolor      = 11           */
     1995           z:height-chars = n + 1
     1996           z:down         = n - 5                                  /* 2 box lines, label text and a separator line         */
     1997         .
     1998   
     1999     end.
     2000   
     2001   &ENDIF
     2002   
     2003     pause 0 before-hide.
     2004   
     2005     return.
     2006   
     2007   end.
     2008   
     2009   
     2010   *** Encrypted Source ***
     2011   *** Encrypted Source ***
     2012   *** Encrypted Source ***
     2013   *** Encrypted Source ***
     2014   *** Encrypted Source ***
     2015   *** Encrypted Source ***
     2016   *** Encrypted Source ***
     2017   *** Encrypted Source ***
     2018   *** Encrypted Source ***
     2019   *** Encrypted Source ***
     2020   *** Encrypted Source ***
     2021   *** Encrypted Source ***
     2022   *** Encrypted Source ***
     2023   *** Encrypted Source ***
     2024   *** Encrypted Source ***
     2025   *** Encrypted Source ***
     2026   *** Encrypted Source ***
     2027   *** Encrypted Source ***
     2028   *** Encrypted Source ***
     2029   *** Encrypted Source ***
     2030   *** Encrypted Source ***
     2031   *** Encrypted Source ***
     2032   *** Encrypted Source ***
     2033   *** Encrypted Source ***
     2034   *** Encrypted Source ***
     2035   *** Encrypted Source ***
     2036   *** Encrypted Source ***
     2037   *** Encrypted Source ***
     2038   *** Encrypted Source ***
     2039   *** Encrypted Source ***
     2040   *** Encrypted Source ***
     2041   *** Encrypted Source ***
     2042   *** Encrypted Source ***
     2043   *** Encrypted Source ***
     2044   *** Encrypted Source ***
     2045   *** Encrypted Source ***
     2046   *** Encrypted Source ***
     2047   *** Encrypted Source ***
     2048   *** Encrypted Source ***
     2049   *** Encrypted Source ***
     2050   *** Encrypted Source ***
     2051   *** Encrypted Source ***
     2052   *** Encrypted Source ***
     2053   *** Encrypted Source ***
     2054   *** Encrypted Source ***
     2055   *** Encrypted Source ***
     2056   *** Encrypted Source ***
     2057   *** Encrypted Source ***
     2058   *** Encrypted Source ***
     2059   *** Encrypted Source ***
     2060   *** Encrypted Source ***
     2061   *** Encrypted Source ***
     2062   *** Encrypted Source ***
     2063   *** Encrypted Source ***
     2064   *** Encrypted Source ***
     2065   *** Encrypted Source ***
     2066   *** Encrypted Source ***
     2067   *** Encrypted Source ***
     2068   *** Encrypted Source ***
     2069   *** Encrypted Source ***
     2070   *** Encrypted Source ***
     2071   *** Encrypted Source ***
     2072   *** Encrypted Source ***
     2073   *** Encrypted Source ***
     2074   *** Encrypted Source ***
     2075   *** Encrypted Source ***
     2076   *** Encrypted Source ***
     2077   *** Encrypted Source ***
     2078   *** Encrypted Source ***
     2079   *** Encrypted Source ***
     2080   *** Encrypted Source ***
     2081   *** Encrypted Source ***
     2082   *** Encrypted Source ***
     2083   *** Encrypted Source ***
     2084   *** Encrypted Source ***
     2085   *** Encrypted Source ***
     2086   *** Encrypted Source ***
     2087   *** Encrypted Source ***
     2088   *** Encrypted Source ***
     2089   *** Encrypted Source ***
     2090   *** Encrypted Source ***
     2091   *** Encrypted Source ***
     2092   *** Encrypted Source ***
     2093   *** Encrypted Source ***
     2094   *** Encrypted Source ***
     2095   *** Encrypted Source ***
     2096   *** Encrypted Source ***
     2097    
     2098   
     2099   
     2100   procedure protopSort:
     2101   
     2102     run lib/sortx.p. /* ( input-output tt_screenList by reference ). */
     2103   
     2104   end.
     2105   
     2106   
     2107   procedure resizeBrowse:
     2108   
     2109     define input parameter zName    as character no-undo.
     2110     define input parameter zMaxRows as integer   no-undo.
     2111   
     2112     define variable oldRows as integer no-undo.
     2113   
     2114     find tt_screenlist where tt_screenList.evtName = zName and tt_screenList.screenType = "browser" no-error.
     2115   
     2116     if available tt_screenlist then
     2117       assign
     2118         oldRows = tt_screenList.maxRows
     2119         tt_screenList.maxRows = max( 2, zMaxRows + 4 )
     2120       .
     2121   
     2122     if available tt_screenlist and oldRows <> tt_screenList.maxRows and valid-handle( tt_screenList.browseHandle ) then
     2123       do:
     2124         run protop_show ( zname ).
     2125         run protop_show ( zname ).
     2126       end.
     2127   
     2128     return.
     2129   
     2130   end.
     2131   
     2132   /*** end ***/
