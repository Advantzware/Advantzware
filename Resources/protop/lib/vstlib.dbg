        1   /*******************************************************************************
        2    *******************************************************************************
        3    **                                                                           **
        4    **                                                                           **
        5    **  Copyright 2003-2006 Tom Bascom, Greenfield Technologies                  **
        6    **  http://www.greenfieldtech.com                                            **
        7    **                                                                           **
        8    **  ProTop is free software; you can redistribute it and/or modify it        **
        9    **  under the terms of the GNU General Public License (GPL) as published     **
       10    **  by the Free Software Foundation; either version 2 of the License, or     **
       11    **  at your option) any later version.                                       **
       12    **                                                                           **
       13    **  ProTop is distributed in the hope that it will be useful, but WITHOUT    **
       14    **  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or    **
       15    **  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License     **
       16    **  for more details.                                                        **
       17    **                                                                           **
       18    **  See TERMS.TXT for more information regarding the Terms and Conditions    **
       19    **  of use and alternative licensing options for this software.              **
       20    **                                                                           **
       21    **  A copy of the GPL is in GPL.TXT which was provided with this package.    **
       22    **                                                                           **
       23    **  See http://www.fsf.org for more information about the GPL.               **
       24    **                                                                           **
       25    **                                                                           **
       26    *******************************************************************************
       27    *******************************************************************************
       28    *
       29    * vstlib.p
       30    *
       31    * Functions that deal with VSTs
       32    *
       33    *
       34    * Known Bugs & Issues:
       35    *
       36    *
       37    * To Do:
       38    *
       39    *
       40    * Author:
       41    *
       42    *      Tom Bascom, Greenfield Technologies
       43    *      http://www.greenfieldtech.com
       44    *      August 28, 2003
       45    *
       46    *
       47    * History:
       48    *
       49    *      Accepted changes from Sam Paakki regarding "quit" function and PROPATH
       50    *      September 26, 2003
       51    *
       52    *      Accepted changes from Patrick Tingen to set html output dir,   
       53    *      eliminating the nasty curr-page shared variable, simplifying the
       54    *      release# and adding protop-url 
       55    *      October 30, 2003
       56    * 
       57    */
       58   
       59   
       60   /*******************************************************************************
       61    *******************************************************************************
       62    **                                                                           **
       63    **                                                                           **
       64    **  Copyright 2003-2006 Tom Bascom, Greenfield Technologies                  **
       65    **  http://www.greenfieldtech.com                                            **
       66    **                                                                           **
       67    **  ProTop is free software; you can redistribute it and/or modify it        **
       68    **  under the terms of the GNU General Public License (GPL) as published     **
       69    **  by the Free Software Foundation; either version 2 of the License, or     **
       70    **  at your option) any later version.                                       **
       71    **                                                                           **
       72    **  ProTop is distributed in the hope that it will be useful, but WITHOUT    **
       73    **  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or    **
       74    **  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License     **
       75    **  for more details.                                                        **
       76    **                                                                           **
       77    **  See TERMS.TXT for more information regarding the Terms and Conditions    **
       78    **  of use and alternative licensing options for this software.              **
       79    **                                                                           **
       80    **  A copy of the GPL is in GPL.TXT which was provided with this package.    **
       81    **                                                                           **
       82    **  See http://www.fsf.org for more information about the GPL.               **
       83    **                                                                           **
       84    **                                                                           **
       85    *******************************************************************************
       86    *******************************************************************************
       87    *
       88    * protop.i
       89    *
       90    * Header file for protop family of programs
       91    *
       92    *
       93    * Known Bugs & Issues:
       94    *
       95    *
       96    * To Do:
       97    *
       98    *
       99    * Author:
      100    *
      101    *      Tom Bascom, Greenfield Technologies
      102    *      http://www.greenfieldtech.com
      103    *      August 28, 2003
      104    *
      105    */
      106   
      107   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 11.4 &THEN
      108   &global-define  FASTLOCK        true
      109   &ELSE
      110   &global-define  FASTLOCK        false
      111   &ENDIF
      112   
      113   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 11.0 &THEN
      114   &global-define  OE11            "yes"
      115   &global-define  xDEBUGTT        false
      116   &ENDIF
      117   
      118   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.2 AND PROVERSION >= "10.2B" &THEN
      119   &global-define  NOSERIALIZE     serialize-hidden
      120   &ENDIF
      121   
      122   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.1 AND PROVERSION >= "10.1B" &THEN
      123   &global-define  BIGINT          int64
      124   &ELSE
      125   &global-define  BIGINT          decimal
      126   &ENDIF
      127   
      128   
      129   /* lib/v9.i
      130    *
      131    */
      132   
      133   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) < 10.0 &THEN
      134   &global-define  CPYLOB  "no"
      135   &global-define  NOW     substitute( "&1 &2", today, string( time, "hh:mm:ss" ))
      136   &global-define  LNGCR   character
      137   &global-define  DTZ     integer
      138   &global-define  BIGINT  decimal
      139   &ELSE
      140   &global-define  OE10    "yes"
      141   &global-define  NOW     now
      142   &global-define  LNGCR   longchar
      143   &global-define  DTZ     datetime-tz
      144   &global-define  BIGINT  int64
      145   &ENDIF
      146    
      147   
      148   /* use extended _connect fields: -client, -cache*
      149    */
      150   
      151   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.1 AND PROVERSION >= "10.1C" &THEN
      152   &global-define  CONNECTX        "yes"
      153   &ELSE
      154   &global-define  CONNECTX        "no"
      155   &ENDIF
      156   
      157   define stream inStrm.
      158   
      159   define new global shared variable dbgMode as integer no-undo initial 1.
      160   
      161   /* The values for these are defined in etc/protop.cfg and set by lib/protop-cfg.p
      162    *
      163    * someday everyone will have OO and I will replace these with a gsv class
      164    * or something of that ilk
      165    *
      166    */
      167   
      168   define new global shared variable pt_shortname   as character no-undo.
      169   define new global shared variable pt_uniqName    as character no-undo.
      170   define new global shared variable pt_server      as character no-undo.
      171   define new global shared variable pt_resrcType   as character no-undo.
      172   
      173   define new global shared variable pt_tmpdir      as character no-undo initial "/tmp".
      174   define new global shared variable pt_logdir      as character no-undo initial "/tmp".
      175   define new global shared variable pt_rptdir      as character no-undo initial "/tmp".
      176   define new global shared variable pt_logname     as character no-undo initial "&5.&2.&3".
      177   define new global shared variable pt_mailcmd     as character no-undo initial 'mailx "-s &1" '.
      178   
      179   define new global shared variable pt_votrx       as integer   no-undo initial 1800.
      180   define new global shared variable pt_lktbllim    as integer   no-undo initial 0.
      181   define new global shared variable pt_bkupstale   as integer   no-undo initial 26.
      182   define new global shared variable pt_bogomips    as integer   no-undo initial 1000000.
      183   define new global shared variable pt_ioresp      as integer   no-undo initial 100.
      184   define new global shared variable pt_ioFileName  as character no-undo.
      185   define new global shared variable pt_dfCmd       as character no-undo.
      186   
      187   define new global shared variable pt_AICheckInterval   as integer no-undo initial 60.
      188   define new global shared variable pt_PICACheckInterval as integer no-undo initial 60.
      189   define new global shared variable pt_appsrvStuck       as integer no-undo initial 120.
      190   
      191   define new global shared variable pt_bibkupAlert as integer   no-undo.          /* alert on long bi backup phase                */
      192   define new global shared variable pt_bibkupAlarm as integer   no-undo.          /* alarm on long bi backup phase                */
      193   define new global shared variable pt_bibkupPage  as integer   no-undo.          /* page  on long bi backup phase                */
      194   
      195   define new global shared variable pt_bkupAlert   as integer   no-undo.          /* alert on long db backup                      */
      196   define new global shared variable pt_bkupAlarm   as integer   no-undo.          /* alarm on long db backup                      */
      197   define new global shared variable pt_bkupPage    as integer   no-undo.          /* page  on long db backup                      */
      198   
      199   define new global shared variable pt_userLock    as logical   no-undo.          /* enable _userLock  data?                      */
      200   define new global shared variable pt_doZippy     as logical   no-undo.          /* enable "user experience" (aka "zippy")?      */
      201   define new global shared variable pt_useRFUtil   as logical   no-undo.          /* use rfutil to gather after-imaging status?   */
      202   
      203   define new global shared variable pt_updAreaData as integer   no-undo.          /* how often should we report storage area xref details from dbanalys? */
      204   
      205   define new global shared variable pt_zoomTo      as integer no-undo.            /* new zoomed monInt                            */
      206   
      207   define new global shared variable ptDBName     as character no-undo.                    /* the db logical name          */
      208   define new global shared variable rowLimit     as integer   no-undo initial 100.        /* 50?                          */
      209   
      210   /* do-sumSample() manipulates these -- ugly, ugly, ugly... (obsolete?)
      211    * 
      212    */
      213   
      214   define new global shared variable stime as integer no-undo.                     /* start time                           */
      215   define new global shared variable ltime as integer no-undo.                     /* last time                            */
      216   define new global shared variable xtime as integer no-undo.                     /* total time                           */
      217   define new global shared variable itime as integer no-undo.                     /* iteration time                       */
      218   
      219   define new global shared variable chkp-base   as integer no-undo initial ?.     /* cover for the lack of a VST field    */
      220   
      221                                                                                   /* corresponding to base checkpoint#    */
      222   /** Global Shared Temp Table Definitions
      223    **
      224    ** Yup, they're shared.  But this stuff makes no sense across session boundaries anyway.
      225    ** And a shared temp-table is logically the same as a db table so who really cares?
      226    **
      227    **/
      228   
      229   /* cache _File and _Index records so that we don't keep hitting the db to translate
      230    */
      231   
      232   define new global shared temp-table tt_tbl no-undo
      233     field xid      as integer                                             /* _File._File-Num              */
      234     field tstatid  as integer                                             /* _TableStat._TableStat-Id     */
      235     field areaNum  as integer                                             /* _Storage-Object._Area-Number */
      236     field tblPool  as character                                           /* get-bits( _object-attrib, 7, 1 ) = 1 */
      237     field tblname  as character                                           /* _File._File-Name             */
      238     index xid-idx is unique primary xid.
      239   
      240   define new global shared temp-table tt_idx no-undo
      241     field xid      as integer                                             /* _Index._Idx-Num              */
      242     field istatid  as integer                                             /* _IndexStat._IndexStat-Id     */
      243     field idxname  as character                                           /* _Index._Idx-Name             */
      244     field idxnote  as character
      245     field idxRoot  as int64                                           /* _Storage-Object._Object-Root */
      246     field tblnum   as integer                                             /* _File._File-Num              */
      247     field areaNum  as integer                                             /* _Storage-Object._Area-Number */
      248     field idxPool  as character                                           /* get-bits( _object-attrib, 7, 1 ) = 1 */
      249     field tblname  as character                                           /* _File._File-Name             */
      250     index xid-idx is unique primary xid.
      251   
      252   define new global shared temp-table tt_areaExtent no-undo
      253     field areaNum  as integer                                             /* _areaExtent._Area-Number     */
      254     field extNum   as integer                                             /* _areaExtent._Extent-Number   */
      255   
      256     field extSize  as decimal                                             /* _areaExtent._Extent-Size     */
      257     field extType  as integer                                             /* _areaExtent._Extent-Type     */
      258     field extPath  as character                                           /* _areaExtent._Extent-Path     */
      259   
      260     index ae-idx is unique primary areaNum extNum.
      261   
      262   define new global shared temp-table tt_area no-undo
      263     field xid      as integer    format ">>>9"
      264     field SANum    as integer    format ">>>9"        label "#"
      265     field areaPool as character  format "x(2)"        label "BX"
      266   /*field areaStatus-Id as {&BIGINT} format ">>>9"    label "Id" */
      267     field SAName   as character  format "x(30)"       label "Area Name"
      268     field allocGB  as decimal    format ">>>>>9.99"   label "Allocated"
      269     field varGB    as decimal    format ">>>>>9.99"   label "Variable"
      270     field totGB    as decimal    format ">>>>>>9.99"  label "Tot GB"
      271     field hiGB     as decimal    format ">>>>>9.99"   label "Hi Water" serialize-hidden
      272     field freeGB   as decimal    format ">>>>>9.99"   label "Free GB"
      273     field pctAlloc as decimal    format ">>>>>9%"     label "%Alloc"
      274     field pctLastX as decimal    format ">>>>9%"      label "%LastX"
      275   
      276     field blkszkb as integer     format ">>9"         label "BSZ"
      277     field rpb     as integer     format ">>9"         label "RPB"
      278     field clstrsz as integer     format ">>9"         label "CSZ"
      279   
      280     field numTbls as integer     format ">>>>9"       label "#Tbls"
      281     field numIdxs as integer     format ">>>>9"       label "#Idxs"
      282     field numLOBs as integer     format ">>>>9"       label "#LOBs"
      283   
      284     field numExts as integer     format ">>>>9"       label "#Exts"
      285     field hasVar  as logical     format "Yes/No"      label "Var?"
      286   
      287     field xnote   as character   format "x"           label "*"
      288   
      289     field areaMaxPct as decimal  format ">>9.999%"    label "Max%"
      290     field idx3264    as decimal  format ">>9.999%"    label "Bug%"
      291   
      292     index pctAlloc-idx is primary pctAlloc descending
      293     index pctLastX-idx pctLastX pctAlloc descending
      294     index allocGB-idx allocGB descending
      295     index totGB-idx totGB descending
      296     index xid-idx is unique xid
      297     index SANum-idx is unique SANum
      298     index SAName-idx is unique SAName
      299   .
      300   
      301   *** Encrypted Source ***
      302   *** Encrypted Source ***
      303   *** Encrypted Source ***
      304   *** Encrypted Source ***
      305   *** Encrypted Source ***
      306   *** Encrypted Source ***
      307   *** Encrypted Source ***
      308   *** Encrypted Source ***
      309   *** Encrypted Source ***
      310   *** Encrypted Source ***
      311   *** Encrypted Source ***
      312   *** Encrypted Source ***
      313   *** Encrypted Source ***
      314   *** Encrypted Source ***
      315   *** Encrypted Source ***
      316   *** Encrypted Source ***
      317   *** Encrypted Source ***
      318   *** Encrypted Source ***
      319   *** Encrypted Source ***
      320   *** Encrypted Source ***
      321   *** Encrypted Source ***
      322   *** Encrypted Source ***
      323   *** Encrypted Source ***
      324   *** Encrypted Source ***
      325   *** Encrypted Source ***
      326   *** Encrypted Source ***
      327   *** Encrypted Source ***
      328   *** Encrypted Source ***
      329   *** Encrypted Source ***
      330   *** Encrypted Source ***
      331   *** Encrypted Source ***
      332   *** Encrypted Source ***
      333   *** Encrypted Source ***
      334   *** Encrypted Source ***
      335   *** Encrypted Source ***
      336   *** Encrypted Source ***
      337   *** Encrypted Source ***
      338   *** Encrypted Source ***
      339   *** Encrypted Source ***
      340   *** Encrypted Source ***
      341   *** Encrypted Source ***
      342   *** Encrypted Source ***
      343   *** Encrypted Source ***
      344   *** Encrypted Source ***
      345   *** Encrypted Source ***
      346   *** Encrypted Source ***
      347   *** Encrypted Source ***
      348   *** Encrypted Source ***
      349   *** Encrypted Source ***
      350   *** Encrypted Source ***
      351   *** Encrypted Source ***
      352   *** Encrypted Source ***
      353   *** Encrypted Source ***
      354   *** Encrypted Source ***
      355   *** Encrypted Source ***
      356   *** Encrypted Source ***
      357   *** Encrypted Source ***
      358   *** Encrypted Source ***
      359   *** Encrypted Source ***
      360   *** Encrypted Source ***
      361   *** Encrypted Source ***
      362   *** Encrypted Source ***
      363   *** Encrypted Source ***
      364   *** Encrypted Source ***
      365   *** Encrypted Source ***
      366   *** Encrypted Source ***
      367   *** Encrypted Source ***
      368   *** Encrypted Source ***
      369   *** Encrypted Source ***
      370   *** Encrypted Source ***
      371    
      372   
      373   /*******************************************************************************
      374    *******************************************************************************
      375    **                                                                           **
      376    **                                                                           **
      377    **  Copyright 2003-2006 Tom Bascom, Greenfield Technologies                  **
      378    **  http://www.greenfieldtech.com                                            **
      379    **                                                                           **
      380    **  ProTop is free software; you can redistribute it and/or modify it        **
      381    **  under the terms of the GNU General Public License (GPL) as published     **
      382    **  by the Free Software Foundation; either version 2 of the License, or     **
      383    **  at your option) any later version.                                       **
      384    **                                                                           **
      385    **  ProTop is distributed in the hope that it will be useful, but WITHOUT    **
      386    **  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or    **
      387    **  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License     **
      388    **  for more details.                                                        **
      389    **                                                                           **
      390    **  See TERMS.TXT for more information regarding the Terms and Conditions    **
      391    **  of use and alternative licensing options for this software.              **
      392    **                                                                           **
      393    **  A copy of the GPL is in GPL.TXT which was provided with this package.    **
      394    **                                                                           **
      395    **  See http://www.fsf.org for more information about the GPL.               **
      396    **                                                                           **
      397    **                                                                           **
      398    *******************************************************************************
      399    *******************************************************************************
      400    *
      401    * protoplib.i
      402    *
      403    * ProTop infrastructure library definitions
      404    *
      405    */
      406   
      407   function uDateTime returns integer () in super.
      408   function string2uDateTime returns integer( input p_text as character ) in super.
      409   function searchDir returns character ( input xDir as character ) in super.
      410   function unsignMe returns decimal ( input s as decimal, input i as integer ) in super.
      411   function hr returns decimal ( input lr as decimal, input osr as decimal, output hr-str as character, output hr as decimal, output mr as decimal ) in super.
      412   function do-SumSample returns logical ( output p_index as integer, output p_time  as integer ) in super.
      413   function myPID returns character () in super.
      414   function hilite returns logical ( input b as handle, input p_metric as character, input p_value as character, output p_attr as character ) in super.
      415   
      416   /* end protoplib.i */
      417    
      418   
      419   /*******************************************************************************
      420    *******************************************************************************
      421    **                                                                           **
      422    **                                                                           **
      423    **  Copyright 2003-2006 Tom Bascom, Greenfield Technologies                  **
      424    **  http://www.greenfieldtech.com                                            **
      425    **                                                                           **
      426    **  ProTop is free software; you can redistribute it and/or modify it        **
      427    **  under the terms of the GNU General Public License (GPL) as published     **
      428    **  by the Free Software Foundation; either version 2 of the License, or     **
      429    **  at your option) any later version.                                       **
      430    **                                                                           **
      431    **  ProTop is distributed in the hope that it will be useful, but WITHOUT    **
      432    **  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or    **
      433    **  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License     **
      434    **  for more details.                                                        **
      435    **                                                                           **
      436    **  See TERMS.TXT for more information regarding the Terms and Conditions    **
      437    **  of use and alternative licensing options for this software.              **
      438    **                                                                           **
      439    **  A copy of the GPL is in GPL.TXT which was provided with this package.    **
      440    **                                                                           **
      441    **  See http://www.fsf.org for more information about the GPL.               **
      442    **                                                                           **
      443    **                                                                           **
      444    *******************************************************************************
      445    *******************************************************************************
      446    *
      447    * vstlib.i
      448    *
      449    * VST library definitions
      450    *
      451    */
      452   
      453   function aiInfo returns character ( input vAiFile as character, output vAiGenNum as integer ) in super.
      454   function chkai returns integer ( output ai_exts as integer, output ai_full as integer, output ai_empty as integer ) in super.
      455   function chkarea returns integer ( input threshold as decimal, output worst as decimal ) in super.
      456   function chkptNum returns integer ( input-output oldbi as integer ) in super.
      457   
      458   function connectFlags returns character ( input cnxId as integer ) in super.
      459   function connectName returns character ( input cnxId as integer, input cnxFlags as character ) in super.
      460   function lastStatement returns character( input cnxId as integer, output lineNum as integer, output procName as character ) in super.
      461   
      462   function isAIEnabled returns logical () in super.
      463   function isReplSource returns logical () in super.
      464   function isReplTarget returns logical () in super.
      465   function isBackupRunning returns logical () in super.
      466   function isWorkgroup returns logical () in super.
      467   
      468   function getStartupX returns character ( input v as character, input p1 as character, input p2 as character ) in super.
      469   
      470   /* end vstlib.i */
      471    
      472   
      473   function add2ds returns logical ( input h as handle ) in super.
      474   function getTempTableHandle returns handle ( input n as character ) in super.
      475   
      476   /* end protop.i */
      477    
      478   
      479   /*** Install self as a session super-procedure
      480    ***
      481    ***/
      482   
      483   session:add-super-procedure( this-procedure ).
      484   
      485   define variable i as integer no-undo.
      486   
      487   define variable hasClstrSz as logical no-undo.
      488   define variable dbRecid    as recid   no-undo.
      489   
      490   find first dictdb._DB no-lock.
      491   dbRecid = recid( _DB ).
      492   
      493   hasClstrSz = no.
      494   find dictdb._File  no-lock where _File-Name = "_Area".
      495   find dictdb._Field no-lock where _Field._File-recid = recid( _File ) and _Field-Name = "_Area-ClusterSize" no-error.
      496   if available _Field then hasClstrSz = yes.
      497   
      498   /*** initialize tt cache for various schema tables
      499    ***
      500    ***/
      501   
      502   empty temp-table tt_tbl.
      503   empty temp-table tt_idx.
      504   empty temp-table tt_areaExtent.
      505   empty temp-table tt_area.
      506   
      507   for each dictdb._File no-lock:
      508   
      509     find first tt_tbl where tt_tbl.tblName = _file._file-name no-error.
      510     if available tt_tbl then next.                                                /* don't build the caches twice...              */
      511   
      512     find dictdb._storageObject no-lock 
      513       where _storageObject._Db-recid = dbRecid
      514         and _Object-type   = 1
      515         and _Object-number = _file._file-num no-error.
      516   
      517     find _area no-lock where _area._area-number = _storageObject._Area-Number no-error.
      518   
      519     create tt_tbl.
      520     assign
      521       tt_tbl.xid = _File._File-num
      522       tt_tbl.areaNum = _storageObject._Area-Number when available _storageObject
      523       tt_tbl.tblPool = "b1"       /* default */
      524       tt_tbl.tblPool = ( if max( get-bits( _object-attrib, 7, 1 ), get-bits( _area-attrib, 7, 1 )) = 0 then "B1" else "B2" ) when available _storageObject
      525       tt_tbl.tblname = _File._File-name
      526     .
      527   
      528     for each dictdb._Index no-lock of dictdb._File:
      529   
      530       find _storageObject no-lock
      531         where _storageObject._Db-recid = dbRecid
      532           and _Object-type   = 2
      533           and _Object-number = _index._idx-num no-error.
      534   
      535       find _area no-lock where _area._area-number = _storageObject._Area-Number no-error.
      536   
      537       create tt_idx.
      538       assign
      539         tt_idx.xid      = _Index._Idx-num
      540         tt_idx.idxname  = _Index._Index-name
      541         tt_idx.tblnum   = _File._File-num
      542         tt_idx.tblname  = _File._File-name
      543         tt_idx.idxnote  = 
      544           ( if dictdb._file._prime-index = recid( _index ) then "P" else "" ) +
      545           ( if _index._unique then "U" else "" )
      546         tt_idx.idxRoot  = int64( _Object-root ) when available _storageObject
      547         tt_idx.areaNum  = int64( _storageObject._Area-Number ) when available _storageObject
      548         tt_idx.idxPool = "b1"     /* default */
      549         tt_idx.idxPool =  ( if max( get-bits( _object-attrib, 7, 1 ), get-bits( _area-attrib, 7, 1 )) = 0 then "B1" else "B2" ) when available _storageObject
      550       .
      551   
      552     end.
      553   
      554   end.
      555   
      556   for each dictdb._areaExtent no-lock:
      557     find tt_areaExtent
      558       where tt_areaExtent.areaNum = _areaExtent._Area-Number and tt_areaExtent.extNum  = _areaExtent._Extent-Number
      559       no-error.
      560     if available tt_areaExtent then next.                                         /* don't build the caches twice...              */
      561     create tt_areaExtent.
      562     assign
      563       tt_areaExtent.areaNum = _areaExtent._Area-Number
      564       tt_areaExtent.extNum  = _areaExtent._Extent-Number
      565       tt_areaExtent.extSize = _areaExtent._Extent-Size
      566       tt_areaExtent.extType = _areaExtent._Extent-Type
      567       tt_areaExtent.extPath = _areaExtent._Extent-Path
      568     .
      569   end.
      570   
      571   for each dictdb._Area no-lock:
      572     if _Area._Area-number <= 3 or _Area._Area-type = 7 then next.         /* skip control area, bi area and after image areas             */
      573     find tt_area where tt_area.SANum = _Area._Area-Number no-error.
      574     if not available tt_area then
      575       do:
      576         find first _AreaStatus no-lock where _AreaStatus-areaNum = _Area._Area-Number.
      577         create tt_area.
      578         assign
      579           tt_area.xid      = _AreaStatus._AreaStatus-Id           /* need an xid field for context        */
      580           tt_area.SANum    = _Area._Area-Number
      581           tt_area.areaPool = "b1"         /* default */
      582           tt_area.areaPool = ( if get-bits( _area-attrib, 7, 1 ) = 0 then "B1" else "B2" )
      583           tt_area.SAName   = string( _Area._Area-Number )         /* temporary    */
      584         .
      585       end.
      586   end.
      587   
      588   /* end caching schema tables
      589    *
      590    */
      591   
      592   
      593   run lib/parsedba.p persistent.
      594   run lib/getdba.p persistent.
      595   
      596   
      597   /*** _TableStat-Id mapping to _File-num is "quirky" when _statbase._tablebase <> 1
      598    ***
      599    ***/
      600   
      601   i = 1.
      602   
      603   do while true:
      604     find _tablestat no-lock where _tablestat-id = i no-error.
      605     if not available _tablestat then
      606       leave.
      607      else
      608       do:
      609         /***
      610         find _file no-lock where _file-num = _tablestat-id no-error.
      611         display i _tablestat-id with down.
      612         if available _file then display _file-num _file-name with down.
      613         down.
      614          ***/
      615         find tt_tbl where tt_tbl.xid = _tablestat-id no-error.
      616         if available tt_tbl then tt_tbl.tstatid = i.      /* NOT _tablestat-id!!!  -- it changes magically */
      617       end.
      618     i = i + 1.
      619   end.
      620   
      621   /*** so is _IndexStat...
      622    ***
      623    ***/
      624   
      625   i = 1.
      626   
      627   do while true:
      628     find _indexstat no-lock where _indexstat-id = i no-error.
      629     if not available _indexstat then
      630       leave.
      631      else
      632       do:
      633         find tt_idx where tt_idx.xid = _indexstat-id no-error.
      634         if available tt_idx then tt_idx.istatid = i.      /* NOT _indexstat-id!!!  -- it changes magically */
      635       end.
      636     i = i + 1.
      637   end.
      638   
      639   return.
      640   
      641   
      642   
      643   /** VST functions
      644    **
      645    **/
      646   
      647   
      648   function connectFlags returns character( cnxId as integer ):
      649   
      650     define variable u_flags as character no-undo.
      651     define variable xflag   as character no-undo.
      652     define variable cc      as character no-undo.
      653     define variable um      as character no-undo.
      654   
      655     find dictdb._Connect no-lock where _Connect-Id = cnxId.
      656   
      657     if       _Connect-type = "self" then
      658       u_flags = "S".
      659      else if _Connect-type = "remc" then
      660       u_flags = "R".
      661      else if _Connect-type = "brok" then
      662       u_flags = "L".
      663      else if _Connect-type = "serv" then
      664       u_flags = "@".
      665      else
      666       u_flags = "O".      /* "Other" -- I'm too lazy to dream up codes right now...       */
      667   
      668   /*** future fun...
      669    ***
      670    ***
      671   
      672       when "serv"  then
      673         do:
      674           find _Servers no-lock where _Server-id = _Connect-usr + 1 no-error.
      675           if available _Servers then
      676             do:
      677               if _Server-type = "Login" then
      678                 tt_Dashboard.con_brok = tt_Dashboard.con_brok  + 1.
      679                else
      680                 tt_Dashboard.con_4glServ = tt_Dashboard.con_4glServ + 1.
      681             end.
      682         end.
      683   
      684    ***
      685    ***/
      686   
      687     if lookup( trim( _connect-type ), "APW,BIW,AIW,WDOG" ) > 0 then u_flags = "H".
      688   
      689   &IF "yes" = "yes" &THEN
      690   
      691     cc =  buffer _connect:handle:buffer-field( "_connect-clientType" ):buffer-value no-error.
      692   
      693     if       cc = "abl" then     u_flags = u_flags + "4".
      694      else if cc = "wta" then     u_flags = u_flags + "W".
      695      else if cc = "apsv" then    u_flags = u_flags + "A".
      696      else if cc = "pasn" then    u_flags = u_flags + "P".
      697      else if cc begins "SQ" then u_flags = u_flags + "Q".
      698      else                        u_flags = u_flags + "X".
      699   
      700   &ENDIF
      701   
      702     /* why, why is it so difficult to determine if a session is a batch session?
      703      * why is _connect-batch a /character/ field?!?
      704      * what is the _connect-device matches "*batch*" logic seen elsewhere all about?
      705      *
      706      */
      707   
      708     if _Connect-device = "batch" or _connect-batch = "yes" then
      709       u_flags = u_flags + "B".
      710      else
      711       u_flags = u_flags + " ".
      712   
      713     /* identify the current process as ProTop 3
      714      */
      715   
      716     find _myconnection no-lock.
      717     if _myconn-pid = _connect-pid then u_flags = "PT3".
      718   
      719   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 11.7 &THEN
      720     um = "".
      721     um =  buffer _connect:handle:buffer-field( "_connect-usermisc" ):buffer-value no-error.
      722     if um begins "pt3:" then
      723       u_flags = "PT3".
      724   &ENDIF
      725   
      726     xflag = "".
      727     if _Connect-TransId    > 0 then xflag = xflag + "*".
      728     if _Connect-Disconnect = 1 then xflag = xflag + "d".
      729     if _Connect-Resync     = 1 then xflag = xflag + "r".
      730     if _Connect-Interrupt  = 1 then xflag = xflag + "i".
      731   
      732     return u_flags + xflag.
      733   
      734   end.
      735   
      736   function connectName returns character( cnxId as integer, cnxFlags as character ):
      737   
      738     define variable u_name  as character no-undo.
      739     define variable cc      as character no-undo.
      740     define variable um      as character no-undo.
      741   
      742     find dictdb._Connect no-lock where _Connect-Id = cnxId.
      743   
      744     if cnxFlags begins "L" or cnxFlags begins "O" or cnxFlags begins "H" or cnxFlags begins "@" then
      745       u_name = trim( substitute( "&1 &2", _connect-name, _connect-type )).
      746      else
      747       u_name = _Connect-name.
      748   
      749   &IF "yes" = "yes" &THEN
      750   
      751     cc =  buffer _connect:handle:buffer-field( "_connect-client" ):buffer-value no-error.
      752   
      753     if cc = "apsv" and u_name = "" then                           /* use the server name or IP for app server connections with no name    */
      754       u_name = _connect-device.
      755   
      756   &ENDIF
      757   
      758     if _connect-type = "remc" and u_name = "" then                /* use the server name or IP for remote connections with no name        */
      759       u_name = _connect-device.
      760   
      761     if u_name = "batch" then u_name = "local".
      762   
      763   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 11.7 &THEN
      764     um = "".
      765     um =  buffer _connect:handle:buffer-field( "_connect-usermisc" ):buffer-value no-error.
      766     if um begins "pt3:" then
      767       u_name = trim( substitute( "&1 &2", u_name, entry( 2, um, ":" ))).
      768   &ENDIF
      769   
      770     /* if there is no name, use the usr# (login with blank id)
      771      *
      772      * used to be _connect-PID but that is less useful than usr#
      773      *
      774      */
      775   
      776     return max( u_name, string( _connect-usr )).
      777   
      778   end.
      779   
      780   function lastStatement returns character( cnxId as integer, output lineNum as integer, output procName as character ):
      781   
      782     define variable ct as character no-undo.
      783     define variable ci as character no-undo.
      784     define variable cl as integer   no-undo.
      785   
      786   &IF "yes" = "yes" &THEN
      787   
      788     find dictdb._Connect no-lock where _Connect-Id = cnxId.
      789   
      790     ct =  buffer _connect:handle:buffer-field( "_connect-clientType" ):buffer-value no-error.
      791     ci =  buffer _connect:handle:buffer-field( "_connect-cacheinfo" ):buffer-value( 1 ) no-error.
      792     cl =  buffer _connect:handle:buffer-field( "_connect-cachelinenumber" ):buffer-value( 1 ) no-error.
      793   
      794     assign
      795       procName  = ( if ci = ? then "" else ci )
      796       lineNum   = ( if cl = ? then 0  else cl )
      797     .
      798   
      799     /* Note: lineNum -1 = "cleanup" at the end of a procedure.    */
      800   
      801     /* eliminate optional internal procedure name if it is not a SQL connection
      802      *
      803      * IPName = trim( entry( 1, _Connect-CacheInfo[1], " " ))
      804      *
      805      */
      806   
      807     if not ( ct begins "SQ" ) and num-entries( ci, " " ) > 1 then
      808       assign
      809         procName  = trim( entry( 2, ci, " " ))
      810       .
      811   
      812     return ( if ct begins "SQ" then procName else substitute( "&1 &2", lineNum, procName )).
      813   
      814   &ELSE
      815   
      816     return "".
      817   
      818   &ENDIF
      819   
      820   end.
      821   
      822   
      823   /* Thanks to George Potemkin!
      824    *
      825    */
      826   
      827   function aiInfo returns character ( input vAiFile as character, output vAiGenNum as integer ):
      828   
      829     DEFINE VARIABLE vAiBlkSize AS INTEGER   NO-UNDO.
      830   
      831     DEFINE VARIABLE vAiStatus  AS INTEGER   NO-UNDO.
      832     DEFINE VARIABLE vStatus    AS CHARACTER NO-UNDO.
      833     DEFINE VARIABLE vRaw       AS RAW       NO-UNDO.
      834   
      835     find first _logging no-lock.
      836     vAiBlkSize = _logging._logging-aiBlkSize.
      837   
      838     file-info:file-name = vAiFile.
      839   
      840     if file-info:full-pathname <> ? and index( file-info:file-type, "r" ) <> 0  and ( vAiBlkSize > 0 ) then
      841       do:
      842   
      843         /* Offset Len  Description
      844          * ------ ---  -----------
      845          * 24-27    4  AiGenNum      AI extent sequence number (mb_aigennbr, Seqno)
      846          * 40-43    4  AiStatus      1=Busy, 2=Empty, 4=Full
      847          *
      848          * v10 moved everything 65 bytes...
      849          * ( if integer( dbversion(1)) > 9 then 65 else 0 ).
      850          */
      851   
      852         INPUT stream inStrm FROM VALUE( vAiFile ).
      853   
      854         ASSIGN LENGTH( vRaw ) = 4.
      855         SEEK stream inStrm TO 24 + vAiBlkSize + ( if integer( dbversion(1)) > 9 then 64 else 0 ).
      856         IMPORT  stream inStrm UNFORMATTED vRaw.
      857         ASSIGN vAiGenNum = GET-LONG( vRaw, 1 ).
      858               
      859         SEEK  stream inStrm TO 40 + vAiBlkSize + ( if integer( dbversion(1)) > 9 then 64 else 0 ).
      860         IMPORT stream inStrm UNFORMATTED vRaw.
      861         ASSIGN vAiStatus = GET-LONG(vRaw, 1).
      862   
      863         ASSIGN LENGTH(vRaw) = 0.
      864         INPUT stream inStrm CLOSE.
      865   
      866         vStatus =
      867           IF       vAiStatus EQ 0 THEN "None"             /* Msg 694      */
      868            ELSE IF vAiStatus EQ 1 THEN "Busy"             /* Msg 3792     */
      869            ELSE IF vAiStatus EQ 2 THEN "Empty"            /* Msg 3793     */
      870            ELSE IF vAiStatus EQ 4 THEN "Full"             /* Msg 3794     */
      871            ELSE IF vAiStatus EQ 8 THEN "Locked"           /* ????         */
      872            ELSE "Unknown".                                /* Msg 737      */
      873   
      874       end.
      875      else
      876       do:
      877         vStatus = "Can not open".
      878       end.
      879   
      880     return vstatus.
      881   
      882   end.    /* aiInfo */
      883   
      884   
      885   /* get consolidated info about a storage area
      886    *
      887    */
      888   
      889   procedure initAreaInfo:
      890   
      891     define variable seqnum     as integer no-undo.
      892   
      893     define variable area_bh    as handle  no-undo.
      894     define variable area_bf    as handle  no-undo.
      895   
      896     for each dictdb._areaStatus:
      897   
      898       if    _AreaStatus-AreaName begins "Control Area"
      899          or _AreaStatus-AreaName begins "Primary Recovery Area"
      900          or _AreaStatus-AreaName begins "After Image Area" then next.
      901   
      902       find tt_area where tt_area.SANum = _AreaStatus-AreaNum.
      903   
      904       find dictdb._Area no-lock where _Area._Area-number = tt_area.SANum.
      905   
      906       assign
      907         tt_area.SAName        = _AreaStatus-Areaname
      908     /*  tt_area.areaStatus-Id = _areaStatus-id */
      909         tt_area.rpb           = exp( 2, _Area._Area-recbits )                     /* thanks to Dmitri Levin!                      */
      910         tt_area.numExts       = _AreaStatus-Extents
      911       .
      912   
      913       /* count the number of storage objects (tables & indexes) in this storage area
      914        */
      915   
      916       assign
      917         tt_area.numTbls = 0
      918         tt_area.numIdxs = 0
      919         tt_area.numLOBs = 0
      920         tt_area.xnote = ""
      921       .
      922   
      923       for each _storageobject no-lock where _StorageObject._DB-Recid = dbRecid
      924            and _storageobject._area-number = tt_area.SANum
      925            and _storageobject._object-num > 0
      926            and _storageobject._object-associate > 0:
      927   
      928         if       _storageobject._object-type = 1 then tt_area.numTbls = tt_area.numTbls + 1.
      929          else if _storageobject._object-type = 2 then tt_area.numIdxs = tt_area.numIdxs + 1.
      930          else if _storageobject._object-type = 3 then tt_area.numLOBs = tt_area.numLOBs + 1.
      931   
      932       end.
      933   
      934       /* if there are data tables or indexes in the schema area (area 6) note it with a "*"
      935        */
      936   
      937       if tt_area.SANum = 6 and ( tt_area.numTbls + tt_area.numIdxs + tt_area.numLOBs ) > 0 then tt_area.xnote = tt_area.xnote + "*".
      938   
      939       if _areaStatus-Areaname matches "*After Image Area*" then tt_area.xNote = aiInfo( input _AreaStatus-LastExtent, output seqnum ).
      940   
      941       if hasClstrSz = false then
      942         tt_area.clstrSz = 0.
      943        else
      944         do:
      945           assign        
      946             area_bh = buffer _Area:handle
      947             area_bf = area_bh:buffer-field( "_Area-ClusterSize" )
      948           no-error.
      949           tt_area.clstrSz = area_bf:buffer-value.
      950         end.
      951   
      952       tt_area.blkSzKB = _Area-blocksize / 1024.                                   /* _area-blocksize is in bytes          */
      953   
      954     end.
      955   
      956     return.
      957   
      958   end.
      959   
      960   
      961   procedure getAreaVarInfo:
      962   
      963     define variable blksAlloc   as decimal no-undo.
      964     define variable blksVar     as decimal no-undo.
      965     define variable blksFree    as decimal no-undo.
      966     define variable extBlks     as decimal no-undo.
      967     define variable lastFixedSz as decimal no-undo.
      968   
      969     define variable x as decimal no-undo.
      970   
      971     x = ( 1024 * 1024 ).
      972   
      973     for each tt_area:
      974   
      975       assign
      976         blksAlloc = 0
      977         blksVar   = 0
      978       .
      979   
      980       /* _AreaExtent._Extent-size is in KB, it is the *planned* size from the .st file,
      981        *  variable extents are reported as zero.
      982        */
      983   
      984       /* functions in WHERE clauses are not fun so use a pre-processor for modern releases and
      985        * save the kludge for ancient, obsolete and unsupported releases...
      986        */
      987   
      988   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.1 AND PROVERSION >= "10.1C" &THEN
      989       find dictdb._AreaStatus no-lock where _AreaStatus-Id = tt_area.xid.
      990   &ELSE
      991       find dictdb._AreaStatus no-lock where int64( _AreaStatus-Id ) = tt_area.xid.
      992   &ENDIF
      993   
      994       lastFixedSz = 0.
      995   
      996       for each tt_AreaExtent no-lock where tt_AreaExtent.areaNum = tt_area.SANum:
      997   
      998         extBlks = ( extSize / tt_area.blkSzKB ).
      999         if extBlks = ? then extBlks = 0.
     1000   
     1001         if extType >= 4 and extType <= 7 then
     1002           assign
     1003             tt_area.hasVar = yes
     1004             blksVar = max( extBlks, ( _AreaStatus-totblocks - blksAlloc ))
     1005           .
     1006          else
     1007           assign
     1008             lastFixedSz = ( extBlks * tt_area.blkSzKB ) / x
     1009             blksAlloc = blksAlloc + extBlks
     1010           .
     1011   
     1012       end.
     1013   
     1014       blksFree = _AreaStatus-Totblocks - _AreaStatus-Hiwater.
     1015       if ( _AreaStatus-Freenum = ? ) then blksFree = blksFree + _AreaStatus-Freenum.
     1016   
     1017       if blksFree = ? then blksFree = _AreaStatus-totblocks.
     1018   
     1019       assign
     1020         /* lastFixedSz     = ( extBlks   * tt_area.blkSzKB ) / x */
     1021         tt_area.allocGB = ( blksAlloc * tt_area.blkSzKB ) / x
     1022         tt_area.varGB   = ( blksVar   * tt_area.blkSzKB ) / x
     1023         tt_area.freeGB  = ( blksFree  * tt_area.blkSzKB ) / x
     1024         tt_area.totGB   = tt_area.allocGB + tt_area.varGB
     1025       .
     1026   
     1027       assign
     1028         tt_area.hiGB     = max( 0, ( tt_area.totGB - tt_area.freeGB ))
     1029         tt_area.pctAlloc = (( tt_area.hiGB / tt_area.allocGB ) * 100 )
     1030       .
     1031   
     1032       if tt_area.pctAlloc = ? then tt_area.pctAlloc = 0.
     1033   
     1034       if lastFixedSz <= 0 then
     1035         tt_area.pctLastX = 0.                     /* there is only a variable length extent - so pctLastX makes no sense  */
     1036        else
     1037         do:
     1038           if _AreaStatus-Hiwater >= blksAlloc then
     1039             tt_area.pctLastX = 100.               /* we have overflowed and we are using the variable extent              */
     1040             else
     1041             do:
     1042               if tt_area.freeGB >= lastFixedSz then
     1043                 tt_area.pctLastX = 0.             /* we are not in the last fixed extent yet                              */
     1044                else
     1045                 tt_area.pctLastX = ( 1 - ( tt_area.freeGB / lastFixedSz )) * 100.
     1046   /* (( /* 1 - */ ( lastFixedSz / ( tt_area.allocGB - tt_area.freeGB ))) * 100 ). */
     1047             end.
     1048         end.
     1049   
     1050       /* if we are within 80% of the 32/64 bit boundry that kbase 000081166 references:
     1051        *   http://knowledgebase.progress.com/articles/Critical_Alert/Critical-Alert-Index-manager-defect-can-corrupt-large-indexes-where-dbkeys-straddle-32-64-bit-boundary
     1052        */
     1053   
     1054       /***
     1055       if ( tt_area.numIdxs > 0 ) then
     1056         do:
     1057           message
     1058             "area name:"    tt_area.SAName
     1059             " hwm:"         _areaStatus-hiWater
     1060             " rpb:"         tt_area.rpb
     1061             " hwm/rpb:"     ( _areaStatus-hiWater / tt_area.rpb )
     1062             " (hwm/rpb)/2^31:"     ( _areaStatus-hiWater / tt_area.rpb ) / exp( 2, 31 )
     1063           .
     1064           pause.
     1065         end.
     1066        ***/
     1067   
     1068       if ( tt_area.numIdxs > 0 ) then
     1069         assign
     1070           idx3264 = (( _areaStatus-hiWater / tt_area.rpb ) / exp( 2, 31 )) * 100
     1071           xNote = xNote + "!" when idx3264 > 80
     1072         .
     1073   
     1074       /***
     1075       if idx3264 > 50 then
     1076         do:
     1077           message "idx3264" SANum _areaStatus-areaName _areaStatus-hiwater tt_area.rpb idx3264.
     1078           pause.
     1079         end.
     1080        ***/
     1081   
     1082       /* if a type1 area is approaching the 32 bit limit then its max area size may be an issue
     1083        * t2 areas seem unlikely to get there anytime soon -- but we may as well calculate it
     1084        */
     1085   
     1086       if /* ( tt_area.clstrSz < 2 ) and */ ( SANum >= 6 ) and (( _areaStatus-Areaname matches "*After Image Area*" ) = no ) then
     1087         assign
     1088   /*      areaMaxPct = (( _areaStatus-hiWater / exp( 2, (( if tt_area.clstrsz < 2 then 31 else 63 ) - ( lookup( string( rpb ), "1,2,4,8,16,32,64,128,256" ) - 1 )))) * 100 ) */
     1089           areaMaxPct = (( _areaStatus-hiWater / tt_area.rpb ) / exp( 2, ( if tt_area.clstrsz < 2 then 31 else 63 ))) * 100
     1090           xNote = xNote + "1" when areaMaxPct > 20
     1091         .
     1092   
     1093       /* my programming license should be revoked for that LOOKUP() stunt -- if you really must ask it is answering "how many bits?"      */
     1094   
     1095       /***
     1096       if areamaxpct > 50 then
     1097         do:
     1098           message "areamaxpct" SANum _areaStatus-areaName _areaStatus-hiwater tt_area.rpb areaMaxPct.
     1099           pause.
     1100         end.
     1101        ***/
     1102   
     1103     end.
     1104   
     1105     return.
     1106   
     1107   end.
     1108   
     1109   
     1110   /* check ai extent status
     1111    *
     1112    */
     1113   
     1114   function chkai returns integer ( output ai_exts as integer, output ai_full as integer, output ai_empty as integer ):
     1115   
     1116     define variable ai_seq  as integer.
     1117     define variable ai_busy as integer.
     1118   
     1119     assign
     1120       ai_exts  = 0
     1121       ai_busy  = 0
     1122       ai_full  = 0
     1123       ai_empty = 0
     1124       ai_seq   = 0
     1125     .
     1126   
     1127     for each _AreaStatus no-lock where ( _areaStatus-Areaname matches "*After Image Area*" ):
     1128   
     1129       ai_exts = ai_exts + 1.
     1130   
     1131       case aiInfo( input _AreaStatus-LastExtent, output ai_seq ):
     1132         when "full"  then ai_full  = ai_full  + 1.
     1133         when "empty" then ai_empty = ai_empty + 1.
     1134         when "busy"  then ai_busy  = ai_exts.
     1135       end.
     1136   
     1137     end.
     1138   
     1139     return ai_busy.
     1140   
     1141   end.
     1142   
     1143   
     1144   /* chkptNum
     1145    *
     1146    */
     1147   
     1148   function chkptNum returns integer ( input-output oldbi as integer ):
     1149   
     1150     /* Adjust to align with checkpoint numbers -- if we can.  _Trans-counter is the
     1151      * checkpoint# since the last "truncate bi".  Unfortunately the only way to map
     1152      * from that number to _BfStatus-LastCkpNum involves starting a transaction in
     1153      * mon-init().  And that is optional since ProTop shouldn't require the user to
     1154      * write to a monitored database.  So if that option isn't enabled (chkp-base = ?)
     1155      * we have to live with the fact that we can't map them.  Which means that we're
     1156      * showing 0 at times when the real active checkpoint is probably something else.
     1157      * That's not as bad as it sounds though because it should only happen when there
     1158      * are no active transactions which means that, while we don't know what the
     1159      * actual current checkpoint # is, we also only have one active checkpoint so
     1160      * there's nothing to be excited about in these two numbers.  (The whole point
     1161      * of this metric is to show growth in the number of active bi clusters.)
     1162      *
     1163      */
     1164   
     1165     define variable currbi as integer no-undo.
     1166   
     1167     assign
     1168       oldbi  = 0
     1169       currbi = 0
     1170     .
     1171   
     1172     /***
     1173     find first dictdb._BuffStatus no-lock no-error.
     1174     if available _BuffStatus then currbi = _BfStatus-LastCkpNum.
     1175     if oldbi = 0 and currbi <> 0 then oldbi = currbi.
     1176      ***/
     1177   
     1178     for each dictdb._Trans no-lock where _Trans-usrnum <> ? and _Trans-state <> "allocated":
     1179       if _Trans-counter <> ? and _Trans-counter > 0 then
     1180         do:
     1181           currbi = max( currbi, _Trans-counter ).
     1182           if oldbi = 0 or _Trans-counter < oldbi then oldbi = _Trans-counter.
     1183         end.
     1184     end.
     1185   
     1186     return currbi.
     1187   
     1188   /*
     1189     for each dictdb._Trans no-lock where _Trans-usrnum <> ? and _Trans-state <> "allocated":
     1190       if _Trans-counter <> ? and _Trans-counter > 0 then
     1191         do:
     1192           if oldbi = 0 or _Trans-counter < oldbi then oldbi = _Trans-counter.
     1193           currbi = max( currbi, _Trans-counter ).
     1194         end.
     1195     end.
     1196   
     1197     find first dictdb._BuffStatus no-lock.
     1198   
     1199     if chkp-base <> ? then
     1200       do:
     1201         currbi = _BfStatus-LastCkpNum.
     1202         if oldbi = 0 then
     1203           oldbi = currbi.
     1204          else
     1205           oldbi = oldbi - chkp-base.
     1206       end.
     1207      else
     1208       do:
     1209         if oldbi = 0 then oldbi = currbi.
     1210       end.
     1211   
     1212     if oldbi > currbi then oldbi = currbi.
     1213   
     1214     return currbi.
     1215    */
     1216   
     1217   end.
     1218   
     1219   
     1220   /* is after-imaging enabled?
     1221    *
     1222    */
     1223   
     1224   function isAIEnabled returns logical ():
     1225   
     1226     find dictdb._Logging no-lock.
     1227   
     1228     return( if _Logging-AIBegin begins "-" then no else yes ).             /* _Logging-AIJournal is apparently broken :(          */
     1229   
     1230   end.
     1231   
     1232   
     1233   /* is this db a replication source?
     1234    *
     1235    */
     1236   
     1237   function isReplSource returns logical ():
     1238   
     1239     find first dictdb._repl-server no-lock no-error.
     1240   
     1241     return available( _repl-server ).
     1242   
     1243   end.
     1244   
     1245   
     1246   /* is this db a replication target?
     1247    *
     1248    */
     1249   
     1250   function isReplTarget returns logical ():
     1251   
     1252     find first dictdb._repl-agent no-lock no-error.
     1253   
     1254     return available( _repl-agent ).
     1255   
     1256   end.
     1257   
     1258   
     1259   /* check to see if a backup is running
     1260    *
     1261    * also: if the backup completed recently (within the sample interval) consider it to be active and set backupStatus = yes
     1262    */
     1263   
     1264   function isBackupRunning returns logical ():
     1265   
     1266     define variable backupStatus as logical no-undo initial no.
     1267   
     1268     define variable currDT  as integer no-undo.
     1269     define variable fBackUp as integer no-undo.
     1270     define variable iBackUp as integer no-undo.
     1271   
     1272     /* is an online backup running?
     1273      */
     1274   
     1275     for each dictdb._userStatus no-lock where _userStatus-operation <> ?:
     1276       if _userStatus-operation = "online backup" then backupStatus = yes.
     1277     end.
     1278   
     1279     /* if the backup completed within the sample interval consider it to be active and set backupStatus = yes
     1280      */
     1281   
     1282     find dictdb._DbStatus no-lock.
     1283   
     1284     assign
     1285       currDT =  uDateTime()
     1286       fBackUp = ( currDT - string2uDateTime( _dbStatus-fbDate ))
     1287       iBackUp = ( currDT - string2uDateTime( _dbStatus-ibDate ))
     1288     .
     1289   
     1290     if fBackup <> ? and fBackup < 300 then backupStatus = yes.
     1291     if iBackup <> ? and iBackup < 300 then backupStatus = yes.
     1292   
     1293     return backupStatus.
     1294   
     1295   end.
     1296   
     1297   
     1298   /* is this db a workgroup db?
     1299    *
     1300    */
     1301   
     1302   function isWorkgroup returns logical ():
     1303   
     1304     return ( integer( getStartUpX( "_Startup-spin", "(-spin)", "" )) <= 1 ).
     1305   
     1306   end.
     1307   
     1308   
     1309   /* try to get startup parameter values that are missing from VSTs from PROMON
     1310    *
     1311    * see dc/promon.txt for sample output
     1312    *
     1313    */
     1314   
     1315   define variable startProMon  as character /* longchar */ /* no-undo */.
     1316   
     1317   procedure loadProMonStartUp:
     1318   
     1319     define variable promonCmd  as character no-undo.
     1320     define variable inLine     as character no-undo.
     1321   
     1322     if opsys = "unix" then
     1323       promonCmd = "$DLC/bin/promon &1 < $PROTOP/etc/promon.startup 2> /dev/null".
     1324      else
     1325       promonCmd = "%DLC%~\bin~\promon &1 < %PROTOP%~\etc~\promon.startup 2> nul".
     1326   
     1327     startProMon = "".
     1328     input stream inStrm through value( substitute( promonCmd, pdbname( 1 ))).
     1329     repeat:
     1330       import stream inStrm unformatted inLine.
     1331       startProMon = startProMon + inLine + "~n".
     1332     end.
     1333     input stream inStrm close.
     1334   
     1335     return.
     1336   
     1337   end.
     1338   
     1339   
     1340   /* gets a startup parameter from promon screen scraping
     1341    *
     1342    * p1 = parameter name in parenthesis
     1343    * p2 = unique text
     1344    *
     1345    */
     1346   
     1347   define variable promonLoaded as logical.
     1348   
     1349   function getProMonParam returns character ( input p1 as character, input p2 as character ):
     1350   
     1351     define variable v as character no-undo.
     1352     define variable t as character no-undo.
     1353   
     1354     define variable i as integer   no-undo.
     1355     define variable n as integer   no-undo.
     1356   
     1357     if promonLoaded = no then
     1358       do:
     1359         run loadProMonStartUp.
     1360         promonLoaded = yes.
     1361       end.
     1362   
     1363     n = num-entries( startProMon, "~n" ).
     1364   
     1365     do i = 1 to n:
     1366   
     1367       t = entry( i, startProMon, "~n" ).
     1368   
     1369       if num-entries( t, ":" ) < 2 then next.
     1370   
     1371       if index( t, p1 ) > 0 then                                                          /* try the parameter name first, i.e. "(-Mxs)"  */
     1372         do:
     1373           v = trim( entry( 2, t, ":" )).
     1374           leave.
     1375         end.
     1376        else if p2 <> "" and index( t, p2 ) > 0 then                                       /* try message text                             */
     1377         do:
     1378           v = trim( entry( 2, t, ":" )).
     1379           leave.
     1380         end.
     1381   
     1382     end.
     1383   
     1384     /*** message substitute( "getProMonParam looking for: [&1] [&2] in &3 lines; found: [&4]", p1, p2, n, v ). pause. ***/
     1385   
     1386     /* pica is specified in KB but reported in MB in the .lg and in PROMON - and reported in bytes in _dbParams, return bytes
     1387      */
     1388   
     1389     if index( p1, "pica" ) > 0 then v = string( decimal( v ) * 1024 * 1024 ) no-error.
     1390   
     1391     return v.
     1392   
     1393   end.
     1394   
     1395   
     1396   define variable hasDBParams  as logical no-undo.
     1397   define variable hasStartup   as logical no-undo.
     1398   
     1399   define variable bdbp as handle no-undo.                                 /* buffer handle for _dbParams (preferred starting with 11.5)   */
     1400   define variable qdbp as handle no-undo.                                 /* query handle for _dbParams (preferred starting with 11.5)    */
     1401   
     1402   define variable bsu  as handle no-undo.                                 /* buffer handle for _startup (removed in oe12)                 */
     1403   define variable qsu  as handle no-undo.                                 /* query handle for _startup (removed in oe12)                  */
     1404   
     1405   procedure chkStartup:
     1406   
     1407     hasDBParams   = no.
     1408     hasStartup    = no.
     1409   
     1410     find dictdb._File no-lock where _File-Name = "_DbParams" no-error.
     1411     if available _File then
     1412       do:
     1413         hasDBParams = yes.
     1414         create buffer bdbp for table "dictdb._DbParams".
     1415         create query qdbp.
     1416         qdbp:set-buffers( bdbp ).
     1417       end.
     1418   
     1419     find dictdb._File no-lock where _File-Name = "_Startup" no-error.
     1420     if available _File then
     1421       do:
     1422         hasStartup = yes.
     1423         create buffer bsu for table "dictdb._Startup".
     1424         create query qsu.
     1425         qsu:set-buffers( bsu ).
     1426       end.
     1427   
     1428     return.
     1429   
     1430   end.
     1431   
     1432   
     1433   /* get db startup parameters - try _dbParams 1st, _startup 2nd, and screen scraping last
     1434    *
     1435    * tt_configuration.excessSHM = integer( getStartUpX( "_Startup-MemOverflow", "(-Mxs)", "Excess shared memory" )) no-error.
     1436    *
     1437    * v  = _startUp field name
     1438    * p1 = parameter name in parenthesis
     1439    * p2 = unique text to find in .lg file or promon output
     1440    *
     1441    */
     1442   
     1443   function getStartupX returns character ( input v as character, input p1 as character, input p2 as character ):
     1444   
     1445     define variable s as character no-undo.
     1446     define variable p as character no-undo.
     1447     define variable x as decimal   no-undo.
     1448     define variable f as decimal   no-undo.
     1449   
     1450     define variable p1x as character no-undo case-sensitive.
     1451   
     1452     p1x = p1.
     1453   
     1454     /* if we have _dbParams go for that first!
     1455      */
     1456   
     1457     if s = "" and hasDbParams = yes then
     1458       do:
     1459   
     1460         qdbp:query-prepare( substitute( 'preselect each _DbParams where _DbParams-name = "&1"', trim( p1x, "()" ))).
     1461         qdbp:query-open.
     1462         if qdbp:get-next( no-lock ) then
     1463           do:
     1464             s = string( bdbp:buffer-field( "_dbParams-Value" ):buffer-value ) no-error.
     1465           end.
     1466         qdbp:query-close.
     1467   
     1468         /*** message substitute( "looking for: [&1] in _dbParams; found [&2]", trim( p1x, "()" ), s ). pause. ***/
     1469   
     1470       end.
     1471   
     1472     /* use _startup if it is available
     1473      */
     1474   
     1475     if s = "" and hasStartup then
     1476       do:
     1477         qsu:query-prepare( 'for each _Startup' ).
     1478         qsu:query-open.
     1479         if qsu:get-first( no-lock ) then
     1480           do:
     1481             s = string( bsu:buffer-field( v ):buffer-value ) no-error.
     1482           end.
     1483         qsu:query-close.
     1484       end.
     1485   
     1486     /* screen scraping -- last resort! :(
     1487      */
     1488   
     1489     if s = "" then
     1490       do:  
     1491   
     1492         /*** message substitute( "did not find: [&1] [&2] [&3]", v, p1x, p2 ). pause. ***/
     1493   
     1494         /* try promon output
     1495          */
     1496   
     1497         s = trim( getProMonParam( p1x, p2 )).
     1498   
     1499         p = s.
     1500         s = entry( 1, s, " " ).
     1501   
     1502         if num-entries( p, " " ) = 2 then
     1503           do:
     1504             if       entry( 2, p, " " ) begins "KB" then f = 1024.
     1505              else if entry( 2, p, " " ) begins "MB" then f = 1024 * 1024.
     1506              else if entry( 2, p, " " ) begins "GB" then f = 1024 * 1024 * 1024.
     1507              else if entry( 2, p, " " ) begins "TB" then f = 1024 * 1024 * 1024 * 1024.
     1508             if f > 0 then
     1509               do:
     1510                 x = ?.
     1511                 x = decimal( s ) no-error.
     1512                 if x <> ? then s = string( x * f ).
     1513               end.
     1514           end.
     1515   
     1516       end.
     1517   
     1518     s = trim( s ).
     1519   
     1520     if s = "" or s = ? then s = "N/A".
     1521   
     1522     return s.
     1523   
     1524   end.
     1525   
     1526   
     1527   /* end vstlib.p */
