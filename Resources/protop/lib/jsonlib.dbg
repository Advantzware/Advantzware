        1   /* jsonlib.p
        2    *
        3    * escapeJSON()
        4    * trimNumStr()
        5    * splitString()
        6    * dataset2JSON()
        7    * JSON2TT()
        8    *
        9    * char2hex()
       10    * hexEncode()
       11    *
       12    */
       13   
       14   
       15   /* lib/v9.i
       16    *
       17    */
       18   
       19   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) < 10.0 &THEN
       20   &global-define  CPYLOB  "no"
       21   &global-define  NOW     substitute( "&1 &2", today, string( time, "hh:mm:ss" ))
       22   &global-define  LNGCR   character
       23   &global-define  DTZ     integer
       24   &global-define  BIGINT  decimal
       25   &ELSE
       26   &global-define  OE10    "yes"
       27   &global-define  NOW     now
       28   &global-define  LNGCR   longchar
       29   &global-define  DTZ     datetime-tz
       30   &global-define  BIGINT  int64
       31   &ENDIF
       32    
       33   
       34   define new global shared variable dbgMode   as integer no-undo initial 2.
       35   define new global shared variable dsSize    as integer no-undo.
       36   
       37   /*** Install self as a session super-procedure
       38    ***
       39    ***/
       40   
       41   session:add-super-procedure( this-procedure ).
       42   
       43   return.
       44   
       45   
       46   /* characters that need to be escaped in JSON strings
       47    *
       48    * \"  Double quote
       49    * \\  Back slash character (reverse solidus)
       50    * \/  Forward slash character (solidus)
       51    *
       52    * \b  Backspace (ascii code 08)
       53    * \f  Form feed (ascii code 0C)
       54    * \n  New line
       55    * \r  Carriage return
       56    * \t  Tab
       57    *
       58    * \uXXXX where XXXX is 4 hex digits
       59    *
       60    */
       61   
       62   function escapeJSON returns character ( input str as character ):
       63   
       64     define variable xJSON as character no-undo.
       65   
       66     xJSON = str.
       67   
       68     xJSON = replace( xJSON, '~\', '~\~\' ).
       69   
       70     xJSON = replace( xJSON, '/', '~\/' ).
       71   
       72     xJSON = replace( xJSON, '"', '~\"' ).
       73   
       74     return xJSON.
       75   
       76   end.
       77   
       78   
       79   function trimNumStr returns character ( input xnum as character ):
       80   
       81     define variable t_value as character no-undo.
       82   
       83     if length( xnum ) = 0 then return "0".
       84   
       85     t_value = trim( xnum ).
       86   
       87     t_value = entry( 1, t_value, " " ).
       88   
       89     t_value = trim( t_value, " %BKMGT" ).
       90   
       91     t_value = replace( t_value, session:numeric-separator, "" ).
       92   
       93     if dbgMode >=9 and t_value <> xnum then
       94       message now "trimmed:" xnum "to" t_value.
       95   
       96     return t_value.
       97   
       98   end.
       99   
      100   
      101   /* peel off the 1st "entry" in a string delimited by "d", returning the 1st entry and the remainder of the string
      102    */
      103   
      104   procedure splitString:
      105   
      106     define input-output parameter s as character no-undo.         /* string to be split                           */
      107     define input-output parameter t as character no-undo.         /* 1st entry                                    */
      108     define input        parameter d as character no-undo.         /* delimiter                                    */
      109     define input        parameter x as integer   no-undo.         /* offset within the delimiter to split at      */
      110   
      111     if index( s, d ) = 0 then
      112       assign
      113         t = s
      114         s = ""
      115       .
      116      else
      117       assign
      118         t  = substring( s, 1, index( s, d ))
      119         s = substring( s, index( s, d ) + x )
      120       .
      121   
      122     return.
      123   
      124   end.
      125   
      126   
      127   procedure dataSet2JSON:
      128   
      129   &IF DEFINED( OE10 ) &THEN
      130     define input parameter dataset-handle ds.
      131   &ELSE
      132     define input parameter ds as handle.
      133   &ENDIF
      134   
      135     define output parameter dsJSON as longchar no-undo.
      136   
      137     define variable i as integer   no-undo.
      138     define variable j as integer   no-undo.
      139   
      140     define variable b as handle    no-undo.                               /* buffer       */
      141     define variable f as handle    no-undo.                               /* field        */
      142     define variable q as handle    no-undo.                               /* query        */
      143   
      144     define variable v as character no-undo.
      145   
      146     dsJSON = '~{"ProDataSet":~{'.
      147   
      148     create query q.
      149     q:forward-only = no.
      150   
      151     /* walk through the buffers in the dataset
      152      */
      153   
      154     dsSize = 0.
      155   
      156   &IF DEFINED( OE10 ) &THEN
      157     do i = 1 to ds:num-buffers:
      158       b = ds:get-buffer-handle( i ).
      159   &ELSE
      160     for each tt_dataset:
      161       b = tt_dataset.ttHandle.
      162       i = i + 1.
      163   &ENDIF
      164   
      165       q:set-buffers( b ).
      166       q:query-prepare( "preselect each " + b:name ).
      167       q:query-open.
      168       q:get-first().
      169   
      170       if b:available then
      171      /* dsJSON = substitute( '&1"&2":[', dsJSON, b:name ). */
      172         dsJSON = dsJSON + substitute( '"&1":[', b:name ).
      173        else
      174         next.
      175   
      176       /* each record in a buffer
      177        */
      178   
      179       do while b:available:
      180   
      181         dsSize = dsSize + b:record-length.
      182   
      183      /* dsJSON = substitute( '&1~{', dsJSON ). */
      184         dsJSON = dsJSON + '~{'.
      185   
      186         /* each field in the record
      187          */
      188   
      189         do j = 1 to b:num-fields:
      190   
      191           /* skip array fields (extent > 0 )
      192            */
      193   
      194           if b:buffer-field( j ):extent <= 1 then
      195             do:
      196   
      197               if b:buffer-field( j ):data-type = "logical" then
      198                 v = trim( string( b:buffer-field( j ):buffer-value, "true/false" )).
      199                else if lookup( b:buffer-field( j ):data-type, "integer,decimal,int64" ) = 0 then
      200                 do:
      201                   v = string( b:buffer-field( j ):buffer-value ).
      202                   v = escapeJSON( v /* trim( v ) */ ).
      203                 end.
      204                else
      205                 do:
      206   
      207                   /* v = string( b:buffer-field( j ):buffer-value ). */
      208   
      209                   v = string( b:buffer-field( j ):buffer-value, b:buffer-field( j ):format ) no-error.
      210                   if error-status:num-messages > 0 then
      211                     do:
      212                       v = string( b:buffer-field( j ):buffer-value ).
      213                       if dbgMode >= 5 then message now "dataSet2JSON()" b:name + "." + b:buffer-field( j ):name "value" v "can not be formatted with mask:" '"' + b:buffer-field( j ):format + '", using unformatted representation instead.'.
      214                     end.
      215   
      216                   v = trimNumStr( v ).
      217   
      218                   /* if length( v ) = 0 then
      219                    *   message "trimmed to naught?!?" b:name b:buffer-field( j ):name b:buffer-field( j ):buffer-value view-as alert-box.
      220                    */
      221   
      222                   v = trim( v ).
      223   
      224                   if v = "" then v = "0".
      225   
      226                   if b:buffer-field( j ):data-type = "decimal" and index( v, "." ) = 0 then
      227                     v = trim( v ) + ".0".
      228   
      229                 end.
      230   
      231               if v = ? then
      232                 do:
      233                   v = "null".
      234                /* dsJSON = substitute( '&1&4"&2":&3', dsJSON, b:buffer-field( j ):name, v, ( if j > 1 then "," else "" )). */
      235                   dsJSON = dsJSON + substitute( '&3"&1":&2', b:buffer-field( j ):name, v, ( if j > 1 then "," else "" )).
      236                 end.
      237                else
      238                 do:
      239                   if lookup( b:buffer-field( j ):data-type, "integer,decimal,int64,logical" ) > 0 then
      240                  /* dsJSON = substitute( '&1&4"&2":&3', dsJSON, b:buffer-field( j ):name, v, ( if j > 1 then "," else "" )). */
      241                     dsJSON = dsJSON + substitute( '&3"&1":&2', b:buffer-field( j ):name, v, ( if j > 1 then "," else "" )).
      242                    else
      243                  /* dsJSON = substitute( '&1&4"&2":"&3"', dsJSON, b:buffer-field( j ):name, v, ( if j > 1 then "," else "" )). */
      244                     dsJSON = dsJSON + substitute( '&3"&1":"&2"', b:buffer-field( j ):name, v, ( if j > 1 then "," else "" )).
      245                 end.
      246   
      247             end.
      248   
      249         end.
      250   
      251         q:get-next().
      252   
      253      /* dsJSON = substitute( '&1}&2', dsJSON, ( if b:available then "," else "" )). */
      254         dsJSON = dsJSON + substitute( '}&1', ( if b:available then "," else "" )).
      255   
      256       end.
      257   
      258       q:query-close.
      259   
      260    /* dsJSON = substitute( '&1]&2', dsJSON, ( if i = ds:num-buffers then "" else "," )). */
      261   
      262    /* dsJSON = dsJSON + substitute( ']&1', ( if i = ds:num-buffers then "" else "," )). */
      263   
      264       dsJSON = dsJSON + '],'.
      265   
      266     end.
      267   
      268     dsJSON = right-trim( dsJSON, ',' ).
      269   
      270     delete object q.
      271   
      272   /*dsJSON = substitute( '&1}}', dsJSON ). */
      273     dsJSON = dsJSON + '}}'.
      274   
      275     return.
      276   
      277   end.
      278   
      279   
      280   procedure JSON2TT:
      281   
      282     define input parameter jFrag    as character no-undo.
      283     define input parameter ttHandle as handle    no-undo.
      284   
      285     define variable jRow   as character no-undo.
      286     define variable jKey   as character no-undo.
      287     define variable jValue as character no-undo.
      288   
      289     do while jFrag <> "":
      290   
      291       run splitString( input-output jFrag, input-output jRow, '~},~{"', 2 ).
      292   
      293       jRow = trim( jRow, '~{~}' ).
      294   
      295       if dbgMode > 4 then message now jRow.
      296   
      297       if jRow <> "" then
      298         ttHandle:buffer-create().
      299   
      300       do while jRow <> "":
      301   
      302         run splitString( input-output jRow, input-output jKey, ',"', 1 ).
      303   
      304         jKey = trim( jKey, ',' ).
      305   
      306         assign
      307           jValue = substring( jKey, index( jKey, '":' ) + 2 )             /* no ":" in key names          */
      308           jKey   = substring( jKey, 1, index( jKey, '":' ))
      309         .
      310   
      311         assign
      312           jKey   = trim( jKey, '"' )
      313           jValue = trim( jValue, '"' )
      314         .
      315   
      316         /* un-escape escaped JSON values
      317          */
      318   
      319         jValue = replace( jValue, '~\/',  '/' ).
      320         jValue = replace( jValue, '~\~\', '~\' ).
      321         jValue = replace( jValue, '~\"',  '"' ).
      322   
      323         if jValue = "null" then jValue = ?.
      324   
      325         ttHandle:buffer-field( jKey ):buffer-value = jValue no-error.
      326   
      327         if dbgMode >= 5 then message now jKey " = " jValue.
      328   
      329       end.
      330   
      331     end.
      332   
      333     return.
      334   
      335   end.
      336   
      337   
      338   /* convert a character to its corresponding 2 digit hex string
      339    *
      340    */
      341   
      342   define variable hex_chars as character no-undo initial "0123456789ABCDEF".
      343   
      344   function char2hex returns character ( input c as character ):
      345   
      346     if length( c ) <> 1 then
      347       return "00".
      348      else
      349       return (
      350         substring( hex_chars, integer( truncate( asc( c ) / 16, 0 )) + 1, 1 ) +
      351         substring( hex_chars, ( asc( c ) modulo 16 ) + 1, 1 )
      352       ).
      353   
      354   end.
      355   
      356   
      357   function hexEncode returns character ( input src as character ):
      358   
      359     define variable xsrc as character no-undo.
      360   
      361     define variable c as character no-undo.
      362     define variable i as integer   no-undo.
      363     define variable n as integer   no-undo.
      364     define variable x as integer   no-undo.
      365   
      366     n = length( src ).
      367   
      368     do i = 1 to n:
      369   
      370       assign
      371         c = substring( src, i, 1 )
      372         x = asc( c )
      373       .
      374   
      375       if  ( x <= 47 ) or                                                  /* anything less than "0"                       */
      376          (( x >= 58 ) and ( x <= 64 )) or                                 /* anything between "9" and "A"                 */
      377          (( x >= 91 ) and ( x <= 96 )) or                                 /* anything between "Z" and "a"                 */
      378           ( x >= 123 ) then                                               /* anything greater than "z"                    */
      379         xsrc = xsrc + "%" + char2hex( c ).
      380        else
      381         xsrc = xsrc + c.
      382   
      383     end.
      384   
      385     return xsrc.
      386   
      387   end.
      388   
      389   
      390   /***
      391   
      392   /* encode non-alphanumeric characters
      393    *
      394    */
      395   
      396   function hexEncode returns character ( input src as character ):
      397   
      398     define variable xtxt as character no-undo.
      399   
      400     assign
      401   
      402   
      403       xtxt = replace(  src, "%",   "%25" )        /* "%" has to go first...       */
      404   
      405       xtxt = replace( xtxt, "~n",  "%0A" )
      406   
      407       xtxt = replace( xtxt, " ",   "%20" )
      408   
      409       xtxt = replace( xtxt, '!',   "%21" )
      410       xtxt = replace( xtxt, '"',   "%22" )
      411       xtxt = replace( xtxt, '#',   "%23" )
      412       xtxt = replace( xtxt, "$",   "%24" )
      413       xtxt = replace( xtxt, "&",   "%26" )
      414       xtxt = replace( xtxt, "'",   "%27" )
      415       xtxt = replace( xtxt, "(",   "%28" )
      416       xtxt = replace( xtxt, ")",   "%29" )
      417       xtxt = replace( xtxt, "*",   "%2A" )
      418       xtxt = replace( xtxt, "+",   "%2B" )
      419       xtxt = replace( xtxt, ",",   "%2C" )
      420       xtxt = replace( xtxt, "-",   "%2D" )
      421       xtxt = replace( xtxt, ".",   "%2E" )
      422   
      423       xtxt = replace( xtxt, ":",   "%3A" )
      424       xtxt = replace( xtxt, ";",   "%3B" )
      425       xtxt = replace( xtxt, "<",   "%3C" )
      426       xtxt = replace( xtxt, "=",   "%3D" )
      427       xtxt = replace( xtxt, ">",   "%3E" )
      428       xtxt = replace( xtxt, "?",   "%3F" )
      429   
      430       xtxt = replace( xtxt, "@",   "%40" )
      431   
      432       xtxt = replace( xtxt, "[",   "%5B" )
      433       xtxt = replace( xtxt, "~\",  "%5C" )
      434       xtxt = replace( xtxt, "]",   "%5D" )
      435       xtxt = replace( xtxt, "^",   "%5E" )
      436       xtxt = replace( xtxt, "_",   "%5F" )
      437   
      438       xtxt = replace( xtxt, "`",   "%60" )
      439   
      440       xtxt = replace( xtxt, "~{",  "%7B" )
      441       xtxt = replace( xtxt, "|",   "%7C" )
      442       xtxt = replace( xtxt, "~}",  "%7D" )
      443       xtxt = replace( xtxt, "~~",  "%7E" )
      444       xtxt = replace( xtxt, chr(127), "%7F" )
      445   
      446     .
      447   
      448     return xtxt.
      449   
      450   end.
      451   
      452    ***/
