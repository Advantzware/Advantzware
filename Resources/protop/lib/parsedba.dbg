        1   /* lib/parsedba.p
        2    *
        3    */
        4   
        5   
        6   /* lib/v9.i
        7    *
        8    */
        9   
       10   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) < 10.0 &THEN
       11   &global-define  CPYLOB  "no"
       12   &global-define  NOW     substitute( "&1 &2", today, string( time, "hh:mm:ss" ))
       13   &global-define  LNGCR   character
       14   &global-define  DTZ     integer
       15   &global-define  BIGINT  decimal
       16   &ELSE
       17   &global-define  OE10    "yes"
       18   &global-define  NOW     now
       19   &global-define  LNGCR   longchar
       20   &global-define  DTZ     datetime-tz
       21   &global-define  BIGINT  int64
       22   &ENDIF
       23    
       24   
       25   
       26   /* lib/dba.i
       27    *
       28    * temp tables used by the dbanalys parser
       29    *
       30    */
       31   
       32   define new global shared temp-table tblist no-undo
       33     field order   as integer   format "->>9" initial -1
       34     field tid     as integer
       35     field tbl     as character format "x(30)"
       36     field ar      as character format "x(30)"
       37     field recs    as decimal   format ">>>>>>>>>>>9"
       38     field tsz     as decimal   format ">>>>>>>>>>>9"
       39     field isz     as decimal   format ">>>>>>>>>>>9"
       40     field trd     as decimal   format ">>>>>>>>>>>9"
       41     field tupd    as decimal   format ">>>>>>>>>9"
       42     field frag    as decimal   format ">>>9.9"
       43     field scat    as decimal   format ">9.9"
       44     field b2      as logical
       45     field rm      as decimal   format ">>>>>>>>>>>9"
       46     field pctfrag as decimal   format ">>>9.99"
       47     field avgrec  as decimal   format ">>>>9.99"
       48     index idxTbl is unique tbl
       49   .
       50   
       51   define new global shared temp-table ixlist no-undo
       52     field order as integer   format "->>9" initial -1
       53     field iid   as integer
       54     field idx   as character format "x(30)"
       55     field ar    as character format "x(30)"
       56     field blks  as decimal   format ">>>>>>>>>>>9"
       57     field pctut as decimal   format ">>>>>>>>>>>9"
       58     field lvls  as decimal   format ">9"
       59     index idxidx is unique idx
       60   .
       61    
       62   
       63   define new global shared variable dbgMode as integer no-undo initial 1.
       64   
       65   define variable r          as integer   no-undo.
       66   define variable x          as character no-undo.
       67   define variable y          as decimal   no-undo.
       68   define variable z          as decimal   no-undo.
       69   define variable xline      as character no-undo extent 512.
       70   define variable curr_area  as character no-undo.
       71   define variable doFixed    as logical   no-undo initial no.
       72   define variable bSize      as integer   no-undo initial 4096.
       73   
       74   define variable ztblName   as character no-undo.
       75   define variable zidxName   as character no-undo.
       76   
       77   define variable db_analx   as character no-undo.
       78   
       79   define variable db_recid   as recid     no-undo.
       80   
       81   define stream tba.              /* input table analysis */
       82   
       83   /*** main block (constructor)
       84    ***
       85    ***/
       86   
       87   session:add-super-procedure( this-procedure ).
       88   
       89   return.
       90   
       91   
       92   function getDecimal returns decimal ( numString as character ):
       93   
       94     define variable x as decimal no-undo.
       95   
       96     case substring( numString, length( numString ), 1 ):
       97   
       98      /* when "G" then  x = decimal( substring( numString, 1, length( numString ) - 1 )) * 1000000000.
       99       * when "M" then  x = decimal( substring( numString, 1, length( numString ) - 1 )) * 1000000.
      100       * when "K" then  x = decimal( substring( numString, 1, length( numString ) - 1 )) * 1000.
      101       */
      102   
      103       when "G" then  x = decimal( substring( numString, 1, length( numString ) - 1 )) * 1024 * 1024 * 1024.
      104       when "M" then  x = decimal( substring( numString, 1, length( numString ) - 1 )) * 1024 * 1024.
      105       when "K" then  x = decimal( substring( numString, 1, length( numString ) - 1 )) * 1024.
      106       when "B" then  x = decimal( substring( numString, 1, length( numString ) - 1 )).
      107   
      108       otherwise      x = decimal( numString ).
      109   
      110     end.
      111   
      112     return x.
      113   
      114   end.
      115   
      116   
      117   procedure RecBlkSum:
      118   
      119     /* 
      120      *    RECORD BLOCK SUMMARY FOR AREA "Employee" : 7
      121      *    -------------------------------------------------------
      122      *                                           -Record Size (B)- ---Fragments--- Scatter
      123      *    Table                Records    Size   Min   Max  Mean      Count Factor  Factor
      124      *    PUB.Benefits              21  848.0B    39    41    40         21    1.0     1.0
      125      *    PUB.Department             7  211.0B    26    35    30          7    1.0     2.0
      126      *    PUB.Employee              55    6.2K    99   135   115         55    1.0     1.0
      127      *    PUB.Family                72    3.1K    38    51    44         72    1.0     1.0
      128      *    PUB.TimeSheet             25    1.1K    42    45    43         25    1.0     1.0
      129      *    PUB.Vacation              12  288.0B    24    24    24         12    1.0     1.0
      130      *    
      131      *                        ------------------------------------------------------------
      132      *    Subtotals:               192   11.7K    24   135    62        192    1.0     1.2
      133      */
      134   
      135     area_block:
      136     repeat on error undo, leave on endkey undo, leave:
      137   
      138       curr_area = xline[6].                                                       /* area name                                    */
      139   
      140       if dbgMode >= 4 then message now "Parsing Record Block Summary for Area: [" curr_area "] " view-as alert-box.
      141   
      142       tables:
      143       repeat:
      144   
      145         xline = ?.
      146         do  on error undo, leave area_block on endkey undo, leave area_block:
      147           import stream tba xline.
      148         end.
      149   
      150         if xline[1] = ? or xline[1] = "" then next tables.
      151   
      152         if xline[1] = "Subtotals:" then
      153           do:
      154             return.                                                               /* end of table data for this storage area      */
      155           end.
      156          else if xline[1] = "INDEX" and xline[2] = "BLOCK" and xline[3] = "SUMMARY" then
      157           do:
      158             message "index block summary inside record block summary!" "current:" curr_area "new:" xline[6] view-as alert-box.
      159             run IdxBlkSum.
      160             return.                                                               /* this shouldn't happen                        */
      161           end.
      162          else if xline[1] = "SUMMARY" and xline[2] = "FOR" and xline[3] = "AREA" then
      163           do:
      164             return.                                                               /* this shouldn't happen                        */
      165           end.
      166          else if xline[1] = "RECORD" and xline[2] = "BLOCK" and xline[3] = "SUMMARY" and xline[4] = "FOR" and xline[5] = "AREA" then
      167           do:
      168             next area_block.                                                      /* this shouldn't happen                        */
      169           end.
      170   
      171         /* process data for a table
      172          */
      173   
      174         if xline[1] begins "PUB." then
      175           do:
      176   
      177             find tblist where tblist.tbl = substring( xline[1], 5 ) no-error.
      178             if not available( tblist ) then
      179               do:
      180                 create tblist.
      181                 assign
      182                   tblist.tbl = trim( substring( xline[1], 5 ))
      183                 .
      184               end.
      185   
      186             tblist.ar  = curr_area.
      187   
      188             if xline[2] <> ? and xline[2] <> "" then                              /* test for a broken line                       */
      189               do:
      190                 assign                                                            /* normal line                                  */
      191                   tblist.recs = tblist.recs + getDecimal( xline[2] )
      192                   tblist.tsz  = tblist.tsz  + getDecimal( xline[3] )
      193                   tblist.frag = tblist.frag + getDecimal( xline[7] )
      194                   tblist.scat = tblist.scat + getDecimal( xline[9] )
      195                 no-error.
      196               end.
      197              else                                                                 /* the line was broken -- record count etc      */
      198               do:                                                                 /* are on the next line                         */
      199                 import stream tba xline.
      200                 assign
      201                   tblist.recs = tblist.recs + getDecimal( xline[1] )
      202                   tblist.tsz  = tblist.tsz  + getDecimal( xline[2] )
      203                   tblist.frag = tblist.frag + getDecimal( xline[6] )
      204                   tblist.scat = tblist.scat + getDecimal( xline[8] )
      205                 no-error.
      206               end.
      207   
      208             /* need a connected db with access to _file etc for the remaining details
      209              */
      210   
      211             find first _file no-lock where _file-name = tblist.tbl no-error.
      212             if not available _file then
      213               do:
      214                 if dbgMode >= 4 then message now "recBlkSum() No such table as:" tblist.tbl view-as alert-box.
      215                 next tables.
      216               end.
      217   
      218             tblist.tid = _file-num.
      219   
      220             find first _storageObject no-lock where
      221                  _storageObject._Db-recid = db_recid and
      222                  _Object-type = 1 and
      223                  _Object-number = _File-Number
      224               no-error.
      225   
      226             if not available( _storageObject ) then
      227               do:
      228                 message now "recBlkSum() Ambiguous:" ambiguous(_storageObject ) tblist.tbl _file-number xLine[1] xLine[2] xLine[3] xLine[4] xLine[5] xLine[6] view-as alert-box.
      229                 next tables.
      230               end.
      231   
      232             tblist.b2  = ( get-bits( _object-attrib, 7, 1 ) = 1 ).
      233   
      234           end.
      235   
      236       end.
      237   
      238     end.
      239   
      240     return.
      241   
      242   end.
      243   
      244   
      245   procedure IdxBlkSum:
      246   
      247     /*
      248      *    INDEX BLOCK SUMMARY FOR AREA "LogData_Idx" : 21
      249      *    -------------------------------------------------------
      250      *    Table                      Index  Fields Levels  Blocks    Size   % Util Factor
      251      *    PUB.logdata
      252      *      db_metric_dt-idx            11       3      4  3648565   15.7G    56.5     1.9
      253      *      log-idx                     10       4      4  4041143   17.5G    56.9     1.9
      254      *      metric-idx                  12       2      4  1109124    4.5G    53.0     1.9
      255      */
      256   
      257     curr_area = xline[6].                                                 /* area name */
      258   
      259     if dbgMode >= 4 then message now "Parsing Index Block Summary for Area: [" curr_area "] " xline[6] view-as alert-box.
      260   
      261     idx_area_block:
      262     repeat on error undo, leave on endkey undo, leave:
      263   
      264       indexes:
      265       repeat:
      266   
      267         xline = ?.
      268         do  on error undo, leave idx_area_block on endkey undo, leave idx_area_block:
      269           import stream tba xline.
      270         end.
      271   
      272         if xline[1] = ? or xline[1] = "" then next indexes.
      273   
      274         if xline[1] = "Subtotals:" then
      275           do:
      276             return.
      277           end.
      278          else if xline[1] = "RECORD" and xline[2] = "BLOCK" and xline[3] = "SUMMARY" then
      279           do:
      280             return.
      281           end.
      282          else if xline[1] = "SUMMARY" and xline[2] = "FOR" and xline[3] = "AREA" then
      283           do:
      284             return.
      285           end.
      286          else if xline[1] = "RECORD" and xline[2] = "BLOCK" and xline[3] = "SUMMARY" and xline[4] = "FOR" and xline[5] = "AREA" then
      287           do:
      288             message "record block summary inside index block summary!" "current:" curr_area "new:" xline[6] view-as alert-box.
      289             run RecBlkSum.
      290             return.
      291           end.
      292   
      293         if xline[1] begins "PUB." then                                    /* we have a table...                           */
      294           idx_loop: do while xline[1] begins "PUB.":
      295   
      296             ztblName = substring( xline[1], 5 ).
      297   
      298             /* read some index data... */
      299   
      300             repeat:
      301   
      302               xline = ?.
      303               do  on error undo, leave idx_area_block on endkey undo, leave idx_area_block:
      304   
      305                 import stream tba xline.
      306   
      307                 if       xline[1] begins "PUB." then next idx_loop.
      308                  else if xline[1] begins "_"    then next idx_area_block.
      309                  else if xline[1] = ? then return.
      310   
      311                 zidxname = ztblName + "." + xline[1].
      312   
      313                 find ixlist where ixlist.idx = zidxName no-error.
      314                 if not available ixlist then
      315                   do:
      316                     create ixlist.
      317                     assign
      318                       ixlist.ar    = curr_area
      319                       ixlist.idx   = zidxName
      320                       ixlist.blks  = decimal( xline[5] )
      321                       ixlist.pctut = decimal( xline[7] )
      322                       ixlist.lvls  = decimal( xline[4] )
      323                     no-error.
      324                   end.
      325   
      326               end.
      327   
      328             end.
      329   
      330             end.
      331   
      332       end.    /* repeat indexes... */
      333   
      334     end.
      335   
      336     return.
      337   
      338   end.
      339   
      340   
      341   procedure RMChain:
      342   
      343     /* oe10
      344      *
      345      *    RM CHAIN ANALYSIS
      346      *    -----------------
      347      * 
      348      *    3 block(s) found in the RM chain of Table object 1
      349      * 
      350      *    20 block(s) found in the RM chain of Table object 3
      351      *
      352      *
      353      * oe11+
      354      * 
      355      *    RM CHAIN ANALYSIS
      356      *    ---------------------------
      357      * 
      358      * 
      359      *    Number of          Object    Object
      360      *    Blocks             Type
      361      *    ------------------------------------------------------------------------------------------------------
      362      *    60                 Table     PUB.Ar-token-facte:60   
      363      */
      364   
      365     if dbgMode >= 4 then message now "Parsing RM Chain Analysis" view-as alert-box.
      366   
      367     rm_chain_block:
      368     repeat on error undo, leave on endkey undo, leave:
      369   
      370       rm_chain:
      371       repeat:
      372   
      373         xline = ?.
      374         do  on error undo, leave rm_chain_block on endkey undo, leave rm_chain_block:
      375           import stream tba xline.
      376         end.
      377   
      378         if xline[1] = ? or xline[1] = "" then next rm_chain.
      379   
      380         if xline[1] begins "---" then
      381           do:
      382   
      383             if proversion >= "11" then next rm_chain.
      384   
      385             repeat:
      386   
      387               xline = ?.
      388               import stream tba xline.
      389   
      390               if xline[1] = ? or xline[1] = "" then next.
      391   
      392               if xline[2] = "block(s)" and xline[9] = "Table" then
      393                 do:
      394   
      395                   find first _file no-lock where _file-number = integer( xline[11] ) no-error.
      396                   if not available _file then
      397                     do:
      398                       if dbgMode >= 4 then message now "rmChain() No such table as:" xline[11] view-as alert-box.
      399                       next.
      400                     end.
      401   
      402                   create tblist.
      403                   assign
      404                     tblist.tbl = _file._file-name
      405                     tblist.tid = _file-num
      406                     tblist.rm  = decimal( xline[1] )
      407                   no-error.
      408   
      409                 end.
      410                else leave.
      411             end.
      412             leave rm_chain_block.
      413           end.
      414   
      415         /* oe11 rm chain
      416          */
      417   
      418         if xline[1] = "Number" and xline[2] = "of" then
      419           do:
      420   
      421             if dbgMode >= 4 then message now "Parsing oe11 rm chain".
      422   
      423             import stream tba xline.
      424             if xline[1] = "Blocks" then
      425               do:
      426                 import stream tba xline.
      427                 if xline[1] begins "----" then
      428                   rm_blocks: repeat:
      429                     xline = ?.
      430                     import stream tba xline.
      431                     if xline[1] = ? then return.
      432                     if xline[2] = "table" then
      433                       do:
      434   
      435                         find tblist where tblist.tbl = entry( 1, substring( xline[3], 5 ), ":" ) no-error.
      436                         if not available( tblist ) then
      437                           do:
      438                             create tblist.
      439                             assign
      440                               tblist.tbl = entry( 1, trim( substring( xline[3], 5 )), ":" )
      441                               /* tblist.ar  = curr_area */
      442                             .
      443                           end.
      444   
      445                         find first _file no-lock where _file-name = tblist.tbl no-error.
      446                         if not available _file then
      447                           do:
      448                             if dbgMode >= 4 then message now "rmChain() No such table as:" tblist.tbl view-as alert-box.
      449                             next rm_blocks.
      450                           end.
      451   
      452                         assign
      453                           tblist.tid = _file-num
      454                           tblist.rm = decimal( xline[1] )
      455                         no-error.
      456   
      457                       end.
      458   
      459                   end. /* rm_blocks */
      460   
      461               end.
      462   
      463           end.
      464   
      465         return.
      466   
      467       end.
      468   
      469     end.
      470   
      471     return.
      472   
      473   end.
      474   
      475   
      476   procedure parseDBA:
      477   
      478     define input parameter db_anal as character no-undo.
      479   
      480     if dbgMode >= 2 then message now "Parsing:" db_anal.
      481   
      482     input stream tba from value( db_anal ).
      483   
      484     find first dictdb._Db no-lock.
      485     db_recid = recid( _db ).
      486   
      487     empty temp-table tblist.
      488     empty temp-table ixlist.
      489   
      490     tba:
      491     repeat on error undo, leave on endkey undo, leave:
      492   
      493       xline = ?.
      494       do  on error undo, leave tba on endkey undo, leave tba:
      495         import stream tba xline.
      496       end.
      497   
      498       if xline[1] = ? or xline[1] = "" then next tba.
      499   
      500       /* ok, we're reading the important stuff...
      501        */
      502   
      503       if       xline[1] = "RECORD" and xline[2] = "BLOCK" and xline[3] = "SUMMARY" and xline[4] = "FOR" and xline[5] = "AREA" then
      504         run RecBlkSum.
      505        else if xline[1] = "INDEX"  and xline[2] = "BLOCK" and xline[3] = "SUMMARY" and xline[4] = "FOR" and xline[5] = "AREA" then
      506         run IdxBlkSum.
      507        else if xline[1] = "RM"     and xline[2] = "CHAIN" and xline[3] = "ANALYSIS" then
      508         run RMChain.
      509   
      510     end.
      511   
      512     input stream tba close.
      513   
      514     if dbgMode >= 2 then message now "Done parsing dbanalys data".
      515   
      516     db_analx = right-trim( search( db_anal ), "dba" ) + "dbx".                    /* "." is treated like a wild-card?     */
      517   
      518     output to value( db_analx ).
      519     for each tblist where tbl <> "":
      520       export tblist.
      521     end.
      522     output close.
      523   
      524     output to value( right-trim( db_analx, "dbx" ) + "idx" ).
      525     for each ixlist where idx <> "":
      526       export ixlist.
      527     end.
      528     output close.
      529   
      530     return.
      531   
      532   end.
