        1   /* clife.p
        2    *
        3    * Conway's Game of Life
        4    *
        5    * https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life
        6    *
        7    *      Any live cell with fewer than two live neighbours dies, as if by underpopulation.
        8    *      Any live cell with two or three live neighbours lives on to the next generation.
        9    *      Any live cell with more than three live neighbours dies, as if by overpopulation.
       10    *      Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.
       11    *
       12    * pro -p clife.p -param "seedfile"
       13    *
       14    * the seed file is lines of text where "x" indicates a live cell, any other
       15    * character a dead cell the following 6x6 example (embedded in the comment
       16    * and indented with a tab) uses "." for dead cells which makes them easier
       17    * to visualize when creating a seed.
       18    *
       19   
       20    blink.seed:
       21   
       22           ......
       23           ..x...
       24           ..x...
       25           ..x...
       26           ......
       27   
       28    beacon.seed:
       29   
       30           ......
       31           .xx...
       32           .x....
       33           ....x.
       34           ...xx.
       35           ......
       36   
       37    glider.seed:
       38   
       39           x..
       40           .xx
       41           xx.
       42   
       43    *
       44    */
       45   
       46   &global-define  WIDTH   128
       47   
       48   define temp-table grid no-undo
       49     field r as integer                                    /* row #                                        */
       50     field a as integer extent 128                    /* live row data                                */
       51     field b as integer extent 128                    /* scratch row data                             */
       52     field s as character format "x(128)"             /* string holding the display values            */
       53     index r-idx is unique primary r
       54   .
       55   
       56   define variable h as integer no-undo.                   /* screen height                                */
       57   define variable w as integer no-undo.                   /* screen width                                 */
       58   
       59   
       60   define variable r1 as integer no-undo extent 128.
       61   define variable r2 as integer no-undo extent 128.
       62   define variable r3 as integer no-undo extent 128.
       63   
       64   define variable gen as integer no-undo.                 /* generation                                   */
       65   define variable y   as integer no-undo.                 /* current population                           */
       66   define variable z   as integer no-undo.                 /* max population                               */
       67   
       68   /* random mutation support ;)
       69    */
       70   
       71   define variable lo  as integer no-undo initial 2.       /* lo random limit, must be <= 1 for randomness to happen       */
       72   define variable hi  as integer no-undo initial 5000.    /* hi random limit, must be > lo                */
       73   
       74   define stream inStrm.
       75   
       76   assign
       77     h = 40        /* screen-lines */                      /* 10x10 is handy for testing                   */
       78     w = 128  /* current-window:width-chars   */      /* make sure to match with format of grid.s     */
       79   .
       80   
       81   form
       82     /* grid.r format "999" */ grid.s skip
       83    with
       84     frame gs
       85     /* no-box */
       86     title " Conway's Game of Life "
       87     no-labels
       88     overlay
       89     h down
       90     row 4
       91     /* centered */
       92     column 16
       93   .
       94   
       95   run seedGrid( session:parameter ).
       96   
       97   /* iterate generations - q to quit, p to pause
       98    */
       99   
      100   do while lastkey <> asc("q"):
      101   
      102     run showGrid.
      103     z = max( y, z ).                                      /* track max population                         */
      104   
      105     put screen row screen-lines + 2 column 1 substitute( " &1 &2 &3   ", gen, y, z ).
      106   
      107     run nextGen.                                          /* calculate the next generation                */
      108     gen = gen + 1.
      109   
      110     readkey pause 0.                                      /* increase pause value to slow things down     */
      111   
      112     if lastkey = asc( "p" ) then                          /* pause updates until a key is pressed         */
      113       readkey.
      114   
      115     if y = 0 and lo > 1 then                              /* if there is no randomness then mutations     */
      116       do:                                                 /* cannot occur thus y = 0 means every cell     */
      117         pause.                                            /* is dead and we are done                      */      
      118         leave.
      119       end.
      120   
      121   end.
      122   
      123   hide frame gs.
      124   
      125   readkey pause 0.
      126   
      127   return.
      128   
      129   /* end of main block
      130    */
      131   
      132   
      133   /* initialize the grid by reading a seed file, if there is no seed file create something fun
      134    */
      135   
      136   procedure seedGrid:
      137   
      138     define input parameter seedFileName as character no-undo.
      139   
      140     define variable i as integer no-undo.
      141     define variable j as integer no-undo.
      142   
      143     /* create a blank grid
      144      */
      145   
      146     empty temp-table grid.
      147   
      148     do i = 1 to h:
      149       create grid.
      150       assign
      151         grid.r = i
      152         grid.a = 0
      153         grid.b = 0
      154       .
      155     end.
      156   
      157     /*  if there is no seed file create something fun
      158      */
      159   
      160     file-info:file-name = seedFileName.
      161     if file-info:full-pathname = ? then
      162       do:
      163   
      164         case random( 1, 5 ):
      165   
      166           when 1 then
      167             do:
      168               find grid where grid.r = 20.
      169               do j = 16 to 112:
      170                 grid.a[j] = 1.
      171               end.
      172             end.
      173   
      174           when 2 then
      175             do:
      176               for each grid:
      177                 if grid.r > 5 and grid.r < 35 then grid.a[64] = 1.
      178               end.
      179             end.
      180   
      181           when 3 then
      182             do:
      183               for each grid:
      184                 if grid.r > 5 and grid.r < 35 then
      185                   assign
      186                     grid.a[43 + grid.r] = 1
      187                     grid.a[44 + grid.r] = 1
      188                     grid.a[83 - grid.r] = 1
      189                     grid.a[84 - grid.r] = 1
      190                   .
      191               end.
      192             end.
      193   
      194           when 4 then
      195             do:
      196               find grid where grid.r = 20.
      197               do j = 16 to 112:
      198                 grid.a[j] = 1.
      199               end.
      200               for each grid:
      201                 if grid.r > 5 and grid.r < 35 then grid.a[64] = 1.
      202               end.
      203             end.
      204   
      205           when 5 then
      206             do:
      207               find grid where grid.r = 20.
      208               do j = 16 to 112:
      209                 grid.a[j] = 1.
      210               end.
      211               for each grid:
      212                 if grid.r > 5 and grid.r < 35 then grid.a[64] = 1.
      213               end.
      214               for each grid:
      215                 if grid.r > 5 and grid.r < 35 then
      216                   assign
      217                     grid.a[43 + grid.r] = 1
      218                     grid.a[44 + grid.r] = 1
      219                     grid.a[83 - grid.r] = 1
      220                     grid.a[84 - grid.r] = 1
      221                   .
      222               end.
      223             end.
      224   
      225         end.
      226   
      227         return.
      228   
      229       end.
      230   
      231     /* load the seed file into the grid
      232      */
      233   
      234     i = 1.                                                /* line/row number                              */
      235   
      236     input stream inStrm from value( file-info:full-pathname ).
      237     do while true:
      238   
      239       find grid where grid.r = i no-error.
      240       if not available grid then leave.                   /* ignore data beyond the defined height        */
      241   
      242       readkey stream inStrm.
      243       if lastkey < 0 then leave.                          /* end of file                                  */
      244   
      245       j = j + 1.                                          /* column number                                */
      246   
      247       if j > w then next.                                 /* ignore data beyond the defined width         */
      248   
      249       if lastkey = 88 or lastkey = 120 then               /* only "X" or "x" count as "live" cells        */
      250         grid.a[j] = 1.
      251   
      252       if lastkey = 10 or lastkey = 13 then                /* newline                                      */
      253         do:
      254           assign
      255             i = i + 1
      256             j = 0
      257           .
      258           if i > h then next.                             /* ignore data beyond the defined height        */
      259         end.
      260   
      261     end.
      262     input stream inStrm close.
      263   
      264     return.
      265   
      266   end.
      267   
      268   
      269   /* check the neighborhood population
      270    */
      271   
      272   function cellStatus returns integer ( r1 as integer extent 128, r2 as integer extent 128, r3 as integer extent 128, c as integer ):
      273   
      274     define variable cl as integer no-undo.        /* neighbor column left         */
      275     define variable cr as integer no-undo.        /* neighbor column right        */
      276   
      277     define variable x  as integer no-undo.        /* current cell                 */
      278     define variable p  as integer no-undo.        /* population of neighbors      */
      279   
      280     /* precompute wrapped column numbers
      281      */
      282   
      283     cl = c - 1.
      284     if cl < 1 then cl = w.                        /* wrap to the end              */
      285     cr = c + 1.
      286     if cr > w then cr = 1.                        /* wrap to the beginning        */
      287   
      288     /* count the neighboring population - but don't count yourself! (r2[c])
      289      *
      290      */
      291   
      292     p = r1[cl] +      r1[c]       + r1[cr] +
      293         r2[cl] +  /** r2[c] **/     r2[cr] +
      294         r3[cl] +      r3[c]       + r3[cr]
      295     .
      296   
      297     x = r2[c].                                    /* state of the current cell    */
      298   
      299     /* x = 1 = live, x = 0 = dead
      300      *
      301      *    Any live cell with fewer than two live neighbours dies, as if by underpopulation.
      302      *    Any live cell with two or three live neighbours lives on to the next generation.
      303      *    Any live cell with more than three live neighbours dies, as if by overpopulation.
      304      *
      305      *    Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.
      306      */
      307   
      308     if (( x = 1 ) and ( p = 2 or p = 3 )) or
      309        (( x = 0 ) and ( p = 3 )) then
      310       do:
      311         if random( lo, hi ) = 1 then
      312           return 0.                               /* random mutation!             */
      313          else
      314           return 1.                               /* normal behavior              */
      315       end.
      316      else 
      317       do:
      318         if random( lo, hi ) = 1 then
      319           return 1.                               /* random mutation!             */
      320          else
      321           return 0.                               /* normal behavior              */
      322       end.
      323   
      324   end.
      325   
      326   
      327   /* calculate the next generation based on the population density of the current generation
      328    */
      329   
      330   procedure nextGen:
      331   
      332     define variable i as integer no-undo.
      333     define variable j as integer no-undo.
      334   
      335     define variable nr as integer no-undo.        /* neighbor row                         */
      336   
      337     /* compute the next generation into the scratch rows
      338      */
      339   
      340     do i = 1 to h:
      341   
      342       nr = i - 1.
      343       if nr < 1 then nr = h.                      /* wrap around to the last row          */
      344       find grid where grid.r = nr no-error.
      345   
      346   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.2 
      347   &THEN
      348       r1 = grid.a.
      349   &ELSE
      350       do j = 1 to w:
      351         r1[j] = grid.a[j].
      352       end.
      353   &ENDIF
      354   
      355       nr = i + 1.
      356       if nr > h then nr = 1.                      /* wrap around to the 1st row           */
      357       find grid where grid.r = nr no-error.
      358   
      359   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.2 
      360   &THEN
      361       r3 = grid.a.
      362   &ELSE
      363       do j = 1 to w:
      364         r3[j] = grid.a[j].
      365       end.
      366   &ENDIF
      367   
      368       find grid where grid.r = i.                 /* find the current grid line last so   */
      369                                                   /* that we can update the current cell  */
      370   
      371   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.2 
      372   &THEN
      373       r2 = grid.a.
      374   &ELSE
      375       do j = 1 to w:
      376         r2[j] = grid.a[j].
      377       end.
      378   &ENDIF
      379   
      380       do j = 1 to w:
      381         grid.b[j] = cellStatus( r1, r2, r3, j ).
      382       end.
      383   
      384     end.
      385   
      386     /* copy the scratch rows to the live rows
      387      */
      388   
      389     for each grid:
      390   &IF DECIMAL(SUBSTRING(PROVERSION,1,INDEX(PROVERSION,".") + 1)) >= 10.2 
      391   &THEN
      392       grid.a = grid.b.
      393   &ELSE
      394       do j = 1 to w:
      395         grid.a[j] = grid.b[j].
      396       end.
      397   &ENDIF
      398     end.
      399   
      400   end.
      401   
      402   
      403   procedure showGrid:
      404   
      405     define variable j as integer no-undo.
      406   
      407     y = 0.                                        /* current live population              */
      408   
      409     for each grid:
      410       grid.s = "".                                /* string display of live vs dead       */
      411       do j = 1 to w:
      412         assign
      413           y = y + grid.a[j]
      414           grid.s = grid.s + ( if grid.a[j] = 0 then " " else "x" )
      415         .
      416       end.
      417       display /* grid.r */ grid.s with frame gs.
      418       down with frame gs.
      419     end.
      420   
      421   end.
