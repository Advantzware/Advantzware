        1   /* zprofiler.p
        2    *
        3    * persistent procedure version of the profiler library
        4    *
        5    * an example procedure showing how to use the PP version of the library is at the end of this file
        6    *
        7    * the stand-alone, non PP, version is documented in zprof_on.p
        8    *
        9    */
       10   
       11   define input parameter zBaseName    as character no-undo.
       12   define input parameter zDescription as character no-undo.
       13   
       14   define temp-table tt_profile
       15     field id          as integer format ">>>>9"
       16     field pdate       as date format "99/99/99"
       17     field description as character format "x(30)"
       18     index profile-idx is unique primary
       19       id
       20     index profile-date
       21       pdate
       22   .
       23   
       24   define temp-table tt_source
       25     field id          as integer format ">>>>9"
       26     field pid         as integer format ">>>>>9"
       27     field pname       as character format "x(40)"
       28     field debug_name  as character format "x(40)"
       29     index source-idx is unique primary
       30       id pid
       31     index source-name
       32       pname
       33   .
       34   
       35   define temp-table tt_tree
       36     field id          as integer format ">>>>9"
       37     field caller      as integer format ">>>>>9"
       38     field src_line    as integer format ">>>>>9"
       39     field callee      as integer format ">>>>>9"
       40     field call_count  as integer format ">>>>>9"
       41     index tree-idx is primary
       42       id caller src_line callee
       43   .
       44   
       45   define temp-table tt_ptime
       46     field id          as integer format ">>>>9"
       47     field pid         as integer format ">>>>>9"
       48     field src_line    as integer format ">>>>>9"
       49     field exec_count  as integer format ">>>>>>>>>9"
       50     field exe_time    as decimal format ">>>>>9.999999"
       51     field tot_time    as decimal format ">>>>>9.999999"
       52     field avg_time    as decimal format ">>>>>9.999999"
       53     index ptime-idx is unique primary
       54       id pid src_line
       55     index avg-idx
       56       avg_time descending
       57     index line-idx
       58       src_line
       59     index ptime-pid-t1
       60       id pid exe_time
       61     index ptime-pid-t3
       62       id pid avg_time
       63     index ptime-t1
       64       id exe_time
       65     index ptime-t3
       66       id avg_time
       67   .
       68   
       69   define temp-table tt_code_line
       70     field pid         as integer   format ">>>>>9"                /* program id#                          */
       71     field src_line    as integer   format ">>>>9"                 /* source line#                         */
       72     field pname       as character format "x(30)"                 /* procedure or class name              */
       73     field ipname      as character format "x(40)"                 /* internal procedure or method name    */
       74     field t1          as decimal   format ">>>>>9.999999"         /* execution time                       */
       75     field t2          as integer   format ">>>>>>>>>9"            /* calls                                */
       76     field t3          as integer   format ">>9"                   /* sessions                             */
       77     field t4          as decimal   format ">>>>>9.999999"         /* average time                         */
       78     index bad-idx1 is unique primary
       79       pid pname src_line
       80     index bad-idx2
       81       t2 t3
       82     index bad-idx3
       83       t1
       84     index avg-idx
       85       t4
       86   .
       87   
       88   define variable profilerOutfile      as character format "x(50)" no-undo.
       89   define variable profilerDescription  as character format "x(50)" no-undo.
       90   define variable profilerStart        as datetime no-undo.
       91   
       92   assign
       93     profilerDescription = zDescription
       94   .
       95   
       96   
       97   /*** Install self as a session super-procedure
       98    ***
       99    ***/
      100   
      101   session:add-super-procedure( this-procedure ).
      102   
      103   message "zprofiler super-procedure added.".
      104   
      105   return.
      106   
      107   
      108   /*********************************************************/
      109   
      110   
      111   procedure zprofiler_on:
      112   
      113     /* append the date and time to the output file name so that we can easily keep a history
      114      */
      115   
      116     profilerOutFile = substitute( "&1&2.&3.&4.&5.&6", session:temp-directory, zBaseName, year( today ), string( month( today ), "99" ), string( day( today ), "99" ), replace( string( time, "hh:mm:ss" ), ":", "." )).
      117   
      118     assign
      119       profilerStart = now
      120       /*
      121        * If these will be used then you must set them to yes BEFORE setting ENABLED to yes...
      122        *
      123        * profiler:listings = yes  /* results is wierd names -- it is much better to explicitly compile with debug-list... */
      124        * profiler:coverage = yes  /* not really relevant... */
      125        */
      126       profiler:enabled     = yes
      127       profiler:description = profilerDescription
      128       profiler:profiling   = yes
      129       profiler:file-name   = profilerOutFile + ".prf"
      130     .
      131   
      132     message "zprofiler enabled" profilerOutFile. /* pause. */
      133   
      134     return.
      135   
      136   end.
      137   
      138   
      139   procedure zprofiler_off:
      140   
      141     message "turning zprofiler off". /* pause. */
      142   
      143     assign
      144       profiler:description = profilerDescription + " [" + string( absolute( interval( profilerStart, now, "seconds" )), "hh:mm:ss" ) + "]"
      145       profiler:enabled     = no
      146       profiler:profiling   = no
      147     .
      148   
      149     message "writing profiler data:" profilerOutFile + ".prf".
      150     profiler:write-data().
      151     message "profiler data written".
      152   
      153     return.
      154   
      155   end.
      156   
      157   
      158   define stream inStrm.
      159   
      160   procedure zprofiler_load:
      161   
      162     define variable i   as integer   no-undo.
      163     define variable v   as integer   no-undo.
      164     define variable dt  as date      no-undo.
      165     define variable dsc as character no-undo.
      166   
      167     define variable profile_id as integer no-undo.
      168   
      169     empty temp-table tt_profile.
      170     empty temp-table tt_source.
      171     empty temp-table tt_tree.
      172     empty temp-table tt_ptime.
      173   
      174     file-info:file-name = profilerOutFile + ".prf".
      175   
      176     if file-info:full-pathname = ? then
      177       do:
      178         message "Cannot find profiler .prf data file:" profilerOutFile.
      179         pause.
      180         return.
      181       end.
      182   
      183     message "loading from:" file-info:full-pathname. /* session:date-format. */ /* pause. */
      184   
      185     input stream inStrm from value( file-info:full-pathname ).
      186   
      187     i = 1.
      188   
      189     repeat:                               /* in theory there could be more than 1?  that would probably break a lot of stuff...   */
      190   
      191       import stream inStrm v /* dt */ ^ dsc no-error.                             /* the profiler apparently ignores session:date-format...       */
      192   
      193       if v <> 1 then
      194         do:
      195           input stream inStrm close.
      196           message "Invalid version:" v.
      197           pause.
      198           return.
      199         end.
      200   
      201       /* message v dt dsc. pause. */                              /* the profiler apparently ignores session:date-format...       */
      202   
      203       profile_id = i.
      204   
      205       create tt_profile.
      206       assign
      207         tt_profile.id          = profile_id
      208         tt_profile.pdate       = today /* dt */
      209         tt_profile.description = dsc
      210       .
      211   
      212       i = i + 1.
      213   
      214     end.
      215   
      216     /* message "profile id:" profile_id. pause. */
      217   
      218     i = 1.
      219   
      220     repeat:
      221   
      222         create tt_source.
      223         tt_source.id = profile_id.
      224         import stream inStrm tt_source.pid tt_source.pname tt_source.debug_name no-error.
      225   
      226         i = i + 1.
      227   
      228     end.
      229   
      230   /*  message i "tt_source loaded". pause.
      231    *  message "creating tt_source session record". pause.
      232    */
      233   
      234     /* create tt_source. */               /* don't CREATE -- an extra will be left over from the REPEAT logic     */
      235     assign
      236       tt_source.id = profile_id
      237       tt_source.pid = 0
      238       tt_source.pname = "Session"
      239       tt_source.debug_name = "Session"
      240     .
      241   
      242     /* message "tt_source session record created". pause. */
      243   
      244     i = 1.
      245   
      246     repeat:
      247   
      248       create tt_tree.
      249       tt_tree.id = profile_id.
      250       import stream inStrm tt_tree.caller tt_tree.src_line tt_tree.callee tt_tree.call_count no-error.
      251   
      252       i = i + 1.
      253   
      254     end.
      255   
      256     delete tt_tree.
      257   
      258     /* message i "tt_tree loaded". pause. */
      259   
      260     i = 1.
      261   
      262     repeat:
      263   
      264       create tt_ptime.
      265       tt_ptime.id = profile_id.
      266       import stream inStrm tt_ptime.pid tt_ptime.src_line tt_ptime.exec_count tt_ptime.exe_time tt_ptime.tot_time no-error.
      267       tt_ptime.avg_time = tt_ptime.exe_time / tt_ptime.exec_count.
      268   
      269       i = i + 1.
      270   
      271     end.
      272   
      273     delete tt_ptime.
      274   
      275     /* message i "tt_ptime loaded". pause. */
      276   
      277     input stream inStrm close.
      278   
      279     return.
      280   
      281   end.
      282   
      283   
      284   procedure zprofiler_proc:
      285   
      286     define variable c  as integer no-undo.
      287     define variable i  as integer no-undo.
      288     define variable t1 as decimal no-undo format ">>>>>9.999999".
      289     define variable t2 as integer no-undo format ">>>>>>>>>9".
      290     define variable t3 as integer no-undo format ">>9".
      291   
      292     define variable srcName    as character no-undo.
      293     define variable iprocName  as character no-undo.
      294   
      295     empty temp-table tt_code_line.
      296   
      297     message "processing".
      298   
      299     for each tt_ptime no-lock by tt_ptime.avg_time descending:     
      300   
      301       /*  if exec_count < 1 /* or src_line = 0 */ then next. */
      302   
      303       find tt_source where
      304            tt_source.id =  tt_ptime.id and
      305            tt_source.pid = tt_ptime.pid no-error.
      306   
      307       if not available( tt_source ) then
      308         srcName = "session".
      309        else
      310         srcName = tt_source.pname.
      311   
      312       if srcName begins "lib/zprofiler/" then next.               /* don't include the profiler */
      313   
      314       find tt_code_line where
      315            tt_code_line.pid      = tt_ptime.pid and
      316            tt_code_line.src_line = tt_ptime.src_line and
      317            tt_code_line.pname    = srcName /* tt_source.pname */ no-error.
      318   
      319       if not available tt_code_line then
      320         do:
      321           create tt_code_line.
      322           assign
      323             i = i + 1
      324             tt_code_line.pid      = tt_ptime.pid
      325             tt_code_line.src_line = tt_ptime.src_line
      326             tt_code_line.pname    = srcName
      327           .
      328         end.
      329   
      330     end.
      331   
      332     message i "entries processed". /* pause. */
      333   
      334     for each tt_code_line:
      335   
      336       assign
      337         tt_code_line.t1 = 0
      338         tt_code_line.t2 = 0
      339       .
      340   
      341       for
      342         each tt_source where
      343           tt_source.pname = tt_code_line.pname,
      344         each tt_ptime where
      345           tt_ptime.id       = tt_source.id  and
      346           tt_ptime.pid      = tt_source.pid and
      347           tt_ptime.src_line = tt_code_line.src_line:      
      348   
      349         assign
      350           tt_code_line.t1 = tt_code_line.t1 + tt_ptime.exe_time
      351           tt_code_line.t2 = tt_code_line.t2 + tt_ptime.exec_count
      352           tt_code_line.t3 = tt_code_line.t3 + 1
      353         .
      354   
      355         if tt_ptime.pid = 0 and tt_ptime.src_line = 0 then tt_code_line.t1 = tt_ptime.tot_time.
      356   
      357       end.
      358   
      359     end.
      360   
      361     for each tt_code_line:
      362   
      363       tt_code_line.t4 = ( tt_code_line.t1 / tt_code_line.t2 ).    /* calculate the average time... */
      364   
      365       if num-entries( tt_code_line.pname, " " ) > 1 then
      366         assign
      367           tt_code_line.ipname = entry( 1, tt_code_line.pname, " " )
      368           tt_code_line.pname  = entry( 2, tt_code_line.pname, " " )
      369         .
      370   
      371     end.
      372   
      373     return.
      374   
      375   end.
      376   
      377   
      378   procedure zprofiler_topx:
      379   
      380     define input parameter toTTY as logical no-undo.
      381   
      382     define variable c  as integer no-undo.
      383     define variable i  as integer no-undo.
      384     define variable t1 as decimal no-undo format ">>>>>9.999999".
      385     define variable t2 as integer no-undo format ">>>>>>>>>9".
      386     define variable t3 as integer no-undo format ">>9".
      387   
      388     define variable t9 as integer no-undo.
      389   
      390     find first tt_profile no-lock no-error.       /* assuming that they're all the same date... */
      391   
      392     for each tt_code_line no-lock where tt_code_line.pname <> "session":
      393       t9 = t9 + tt_code_line.t1.
      394     end.
      395   
      396     if toTTY = no then output to value( profilerOutFile + ".rpt" ).
      397     
      398     display
      399       tt_profile.description  label "Description" format "x(70)" skip
      400       "Session Total Execution Time  " string( t9, "hh:mm:ss" )  skip
      401       "Line 0 = initialization, line -1 = cleanup"               skip
      402      with frame prof-hdr
      403        title " Profiler: Top 20 Results "
      404        width 120
      405        centered
      406        overlay
      407        side-labels
      408        row 4
      409     .
      410   
      411     i = 0.
      412   
      413     for each tt_code_line no-lock by tt_code_line.t1 descending:
      414   
      415       if tt_code_line.pname = "session" then next.
      416   
      417       i = i + 1.
      418   
      419       if i <= 20 then
      420         do:
      421           display
      422             tt_code_line.pname    label "Program/Class"
      423             tt_code_line.src_line label "Line"
      424             tt_code_line.t1       label "Time"
      425             tt_code_line.t4       label "Avg Time"
      426             tt_code_line.t2       label "Calls"
      427             tt_code_line.ipname   label "Internal Procedure/Method"
      428            with frame prof-rpt
      429              title " Top 20 Lines: Total Execution Time "
      430              width 120
      431              centered
      432              overlay
      433              20 down
      434              row 9
      435           .
      436         end.
      437   
      438       if i > 20 then leave.               /* Top 20... */
      439   
      440     end.
      441   
      442     if toTTY = no then
      443       output close.
      444      else
      445       do:
      446         pause.
      447         hide frame prof-rpt.
      448         hide frame prof-hdr.
      449       end.
      450   
      451     return.
      452   
      453   end.
      454   
      455   /******/
      456   
      457   /*** example usage
      458    ***
      459    ***
      460   
      461   /* use the profiler to help debug performance issues
      462    */
      463   
      464   define variable zprofilerState as logical initial ?.
      465   
      466   procedure myProfiler:
      467   
      468     if zprofilerState = yes then                          /* the profiler is already running                              */
      469       do:
      470   
      471         run zprofiler_off.                                /* flip the state of the profiler to "off"                      */
      472         zprofilerState = no.
      473         run zprofiler_load.                               /* load profiler data into temp-tables to analyze               */
      474         run zprofiler_proc.                               /* process the data                                             */
      475         run zprofiler_topx( no ).                         /* report on the top 20 execution time lines -- to file         */
      476         run zprofiler_topx( yes ).                        /* report on the top 20 execution time lines -- to TTY          */
      477   
      478         return.                                           /* do not continue after this -- return                         */
      479   
      480       end.
      481   
      482     if zprofilerState = ? then                            /* we need to launch the profiler                               */
      483       do:
      484         run lib/zprofiler.p persistent (                  /* launch the PP                                                */
      485           "zprofiler",                                    /* output file basename                                         */
      486           "Execution Profile"                             /* description                                                  */
      487         ).
      488         zprofilerState = yes.                             /* enable the profiler at initial launch                        */
      489       end.
      490   
      491     if zprofilerState = no then                           /* profiler has previously been launched (state <> ?)           */
      492       zprofilerState = yes.                               /* so the user is just starting another set of data             */
      493   
      494     if zprofilerState = yes then                          /* a profiling dataset is being requested                       */
      495       do:                                                 /* either from the initial launch or a subsequent request       */
      496         run zprofiler_on.
      497         zprofilerState = yes.
      498       end.
      499   
      500     return.
      501   
      502   end.
      503   
      504    ***
      505    ***
      506    ***/
      507   
